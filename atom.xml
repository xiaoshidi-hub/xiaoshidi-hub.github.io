<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>智果小芯</title>
  
  <subtitle>果果小师弟</subtitle>
  <link href="http://liuyao-blog.cn/atom.xml" rel="self"/>
  
  <link href="http://liuyao-blog.cn/"/>
  <updated>2021-08-24T05:51:54.420Z</updated>
  <id>http://liuyao-blog.cn/</id>
  
  <author>
    <name>智果小芯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何正确的理解单片机的结构体</title>
    <link href="http://liuyao-blog.cn/posts/1003.html"/>
    <id>http://liuyao-blog.cn/posts/1003.html</id>
    <published>2021-08-23T08:24:49.000Z</published>
    <updated>2021-08-24T05:51:54.420Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：听说还有好多学单片机的小伙伴不会用结构体？指针和结构体是学单片机必须要掌握的，如果你C语言掌握的不牢，单片机根本学不到精髓，只能完成一些低级的项目。看得懂结构体并且能够灵活运用结构体才能说你入门了单片机。本篇将以最通俗的方式结合STM32单片来讲讲结构体的运用。解决你学完C语言、考过了计算机二级还是看不懂单片机结构体的苦恼。宝藏文章，记得点赞转发收藏。</p><p>大家知道指针和结构体是单片机的难点，所以就去学习C语言，找视频看书……</p><p><img src="https://img-blog.csdnimg.cn/20210508114736805.png" alt=" "></p><p>这里面每一个视频的播放量都非常高。对于单纯的学习C语言，这里讲的很清楚。看完你不禁在下面评论一句：哇！讲的真的太清楚了吧！但是等你真正的学单片机的时候，你会发现我不是学过C语言吗？计算机二级我也过了啊！怎么这个指针和结构体都不懂啊？<strong>难道我学了一个假的C语言？</strong></p><p><img src="https://img-blog.csdnimg.cn/20210508115303525.jpg" alt=" "></p><p>其实这不是你的错，也不是单片机的错，而是<strong>在C语言和单片机之间需要一个过渡</strong>！这个需要过渡的点在很多单片机视频教程中并没有去讲解。因为教育机构默认你是知道的，所以在讲流水灯时他们并不会讲解GPIO初始化这个结构体，因为默认你是知道如何操作的。</p><p><img src="https://img-blog.csdnimg.cn/20210508120017722.png" alt=" "></p><p>申明一个<code>GPIO_InitTypeDef</code>的结构体，然后在<code>LED_Init(void)</code>函数中定义一个<code>GPIO_InitStructure</code>的变量<code>GPIO_InitStructure</code>，那么这个变量就可以设置这个<code>GPIO_InitTypeDef</code>的结构体中的成员。这里先做了解，请接着往下看。</p><h2 id="1、为什么需要结构体"><a href="#1、为什么需要结构体" class="headerlink" title="1、为什么需要结构体"></a>1、为什么需要结构体</h2><p>这里先不说什么是结构体，说说为什么需要结构体？只有知道为什么需要，才能按照你的需要去学习，这样效率才会高。你才知道在什么情况下我们需要写一个结构体，怎么样去用结构体。</p><p>这里我们以一个智能家居的项目为例。</p><p>先来看一个实际的问题</p><p>话说有一个项目上有4个传感器：光照传感器、烟雾传感器、酒精传感器、湿度传感器。然后这四个各个传感器还有设置报警的阈值范围。</p><p>一般都是这样写</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*记录传感器的数值*/</span></span><br><span class="line"><span class="keyword">float</span> temperature;<span class="comment">//温度</span></span><br><span class="line"><span class="keyword">char</span>  humidity;<span class="comment">//湿度</span></span><br><span class="line"><span class="keyword">char</span>  alcohol;<span class="comment">//酒精浓度</span></span><br><span class="line"><span class="keyword">int</span>   illumination;<span class="comment">//光照强度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*记录传感器高低阈值*/</span></span><br><span class="line"><span class="keyword">float</span> temperature_threshold[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">float</span> humidity_threshold[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">float</span> alcohol_threshold[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">float</span> illumination_threshold[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uart_init(<span class="number">115200</span>);<span class="comment">//串口初始化</span></span><br><span class="line">    delay_init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210508143019776.png" alt=" "></p><p>当然你做一个项目肯定还定义了很多其他的变量，还需要记录其它变量</p><p><img src="https://img-blog.csdnimg.cn/20210508143224532.png" alt=" "></p><p>然后过了几天又增加了个一氧化碳传感器</p><p><img src="https://img-blog.csdnimg.cn/20210508143559252.png" alt=" "></p><p>然后过了几天，每个传感器还需要加个是否正常工作的标志位</p><p><img src="https://img-blog.csdnimg.cn/20210508143848281.png" alt=" "></p><p>因为项目的需要，然后又增加了4个相同的传感器：温湿度、光照强度、烟雾浓度、酒精浓度。</p><p><img src="https://img-blog.csdnimg.cn/20210508144258329.png" alt=" "></p><p>然后又增加了4个相同的传感器 温湿度、光照强度、烟雾浓度、酒精浓度。</p><p>截图截不开了….</p><p><img src="https://img-blog.csdnimg.cn/20210508144435927.png" alt=" "></p><p>满屏的变量……</p><p>满屏的变量……</p><p>满屏的变量……</p><p>在项目刚开始做的时候如果不能未雨绸缪，接着干下去整个程序代码别说维护了，就是接着写都让人头疼!</p><p>满屏的变量…</p><p>满屏的变量…</p><h2 id="2、结构体闪亮登场"><a href="#2、结构体闪亮登场" class="headerlink" title="2、结构体闪亮登场"></a>2、结构体闪亮登场</h2><p>然后搞C语言那帮家伙就造了个功能<code>struct</code></p><p>1、<strong>结构体就是可以把变量包含到里面的东西</strong></p><p>struct就代表要定义一个结构体<br>sensors是这个结构体的名字<br>然后是一个大括号 { }</p><p>大括号里面就随意定义变量啦~</p><p><img src="https://img-blog.csdnimg.cn/20210508144815690.png" alt=" "></p><p>怎么使用里面的变量呢?</p><p>注意<strong>结构体是一个数据类型</strong><br>就像是int和char一样的这种类型</p><p>既然是一种数据类型</p><p>那么就可以用这个数据类型定义变量</p><p>定义一个该结构体的变量</p><p><img src="https://img-blog.csdnimg.cn/20210508145009297.png" alt=" "></p><p>为啥要那样子定义啊？</p><p>答：你去问造C语言的那帮家伙去！问问他们为啥要设计成这样子！</p><p>然后操作结构体变量里面的成员变量。当我们定义好结构体变量后，在初始化变量里面的成员变量时就会自动出现结构体里面的成员变量，如果这个代码是你一个一个敲出来的话，你就会感叹结构体在单片机中是那么的奇妙！</p><p><img src="https://img-blog.csdnimg.cn/20210508145158307.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508150048506.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508150014381.png" alt=" "></p><p>有人会问为啥是结构体变量中间加个点？</p><p>答：你去问造C语言的那帮家伙去！问问他们为啥要设计成这样子。</p><p>2、其实定义结构体变量可以下面这样子</p><p><img src="https://img-blog.csdnimg.cn/20210508150245469.png" alt=" "></p><p>也可以定义多个</p><p><img src="https://img-blog.csdnimg.cn/20210508150457587.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508150526128.png" alt=" "></p><p>发现了没，每个结构体变量都是单独拥有结构体里面的全部成员变量。</p><p>就像是最开始说的，如果再增加一套传感器：温湿度、光照强度、烟雾浓度、酒精浓度。</p><p>使用结构体的话<strong>只需要再定义一个结构体变量即可</strong>。</p><p>但是很多时候我们在单片机中见到的结构体并不是上面那样定义的，而是在前面加了一个typedef关键字。</p><p>这样的例子在库函数的头文件中我们经常会看到如下结构体</p><p><img src="https://img-blog.csdnimg.cn/20210508151040906.png" alt=" "></p><h2 id="3、typedef关键字"><a href="#3、typedef关键字" class="headerlink" title="3、typedef关键字"></a>3、typedef关键字</h2><p>先看一下百度百科对<code>typedef</code>的定义</p><p><img src="https://img-blog.csdnimg.cn/20210508210617163.png" alt=" "></p><p>总结一句就是：<code>typedef</code>可以把一个数据类型取一个别的名字</p><p>typedef {数据类型}  {别的名字}</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zhjiguoxin;<span class="comment">//zhjiguoxin就是int</span></span><br><span class="line"></span><br><span class="line">zhjiguoxin value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uart_init(<span class="number">115200</span>);<span class="comment">//串口初始化</span></span><br><span class="line">    delay_init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value=%d\r\n&quot;</span>,value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210508211129431.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508211232134.png" alt=" "></p><p>虽然typedef可以给变量取别名，但是没有谁回像上面那样取名字，我这里知识举一个例子。</p><h2 id="4、结构体的精髓"><a href="#4、结构体的精髓" class="headerlink" title="4、结构体的精髓"></a>4、结构体的精髓</h2><p>注意下:</p><p>1、下面的代表了这个结构体数据类型</p><p><img src="https://img-blog.csdnimg.cn/20210508211718192.png" alt=" "></p><p>2、给这个数据类型起一个别名</p><p>注意是三部分,  typedef  {数据类型}  {别的名字}。所以sensor就代表了这个结构体了。</p><p>建议初学者把下面这张图保存到你的电脑，这样你就永远也不会忘记typedef在结构体中的用法了，也能很快的记住结构体这个东东。</p><p><img src="https://img-blog.csdnimg.cn/202105082122463.png" alt=" "></p><p>3、以后定义结构体变量的时候就不需要像最开始那样struct sensors sen;这样的定义结构体变量了，只需要sensors sen；即可</p><p><img src="https://img-blog.csdnimg.cn/2021050821233477.png" alt=" "></p><p>4、结构体名字可以省略</p><p>注意结构体定义可以不写结构体名，对C语言来说，那个sensors不叫结构体名，而是叫标签(tag)。C语言结构体名是struct关键字 + tag。所以为了简便我们看到的单片机中的结构体都是写成如下的形式。</p><p><img src="https://img-blog.csdnimg.cn/2021050821242043.png" alt=" "></p><h2 id="5、结构体的变量可以放任何变量"><a href="#5、结构体的变量可以放任何变量" class="headerlink" title="5、结构体的变量可以放任何变量"></a>5、结构体的变量可以放任何变量</h2><p>1、结构体变量可以放任何变量(<strong>int型指针</strong>)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> temperature; <span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">char</span>  humidity;  <span class="comment">//湿度</span></span><br><span class="line">    <span class="keyword">char</span>  alcohol; <span class="comment">//酒精浓度</span></span><br><span class="line">    <span class="keyword">int</span>   illumination;<span class="comment">//光照强度</span></span><br><span class="line">    <span class="keyword">char</span>  CO;<span class="comment">//一氧化碳浓度</span></span><br><span class="line">    <span class="keyword">int</span>   *p;  <span class="comment">//int型的指针变量</span></span><br><span class="line">&#125; sensor;</span><br><span class="line">sensor sen;</span><br><span class="line"><span class="keyword">int</span> value =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uart_init(<span class="number">115200</span>);<span class="comment">//串口初始化</span></span><br><span class="line">    delay_init();</span><br><span class="line">    sen.p=&amp;value;<span class="comment">//把value的地址赋值</span></span><br><span class="line">    <span class="comment">//打印p代表的地址里面的值(其实就是打印value的值)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value=%d\r\n&quot;</span>,*(sen.p));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是指针变量，所以给指针变量赋值时当然是赋值的是一个地址。</p><p><img src="https://img-blog.csdnimg.cn/20210508212835877.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508212956678.png" alt=" "></p><p>2、结构体变量可以放任何变量(<strong>函数指针</strong>)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> temperature; <span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">char</span>  humidity;  <span class="comment">//湿度</span></span><br><span class="line">    <span class="keyword">char</span>  alcohol;   <span class="comment">//酒精浓度</span></span><br><span class="line">    <span class="keyword">int</span>   illumination;<span class="comment">//光照强度</span></span><br><span class="line">    <span class="keyword">char</span>  CO;  <span class="comment">//一氧化碳浓度</span></span><br><span class="line">    <span class="keyword">int</span>   *p;  <span class="comment">//int型的指针变量</span></span><br><span class="line">    <span class="keyword">void</span> (*fun)();</span><br><span class="line">&#125; sensor;</span><br><span class="line">sensor sen;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;zhiguoxin\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uart_init(<span class="number">115200</span>);<span class="comment">//串口初始化</span></span><br><span class="line">    delay_init();</span><br><span class="line">    sen.fun=function;</span><br><span class="line">    sen.fun();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是函数指针变量，所以给函数指针变量赋值时当然是赋值的是的也是地址，并且还要是一个函数的地址，而一个函数的函数名就是该函数的地址。所以才会有下面的把函数function();的地址function赋值给函数指针fun。这样大家是不是很清楚了。如果不清楚建议看个3遍以上！</p><p><img src="https://img-blog.csdnimg.cn/20210508214146152.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508214219368.png" alt=" "></p><p>3、结构体变量可以放任何变量(<strong>结构体变量</strong>)</p><p>这就是结构体嵌套，在一个结构体内包含了另一个结构体作为其成员。当出现结构体嵌套时，必须以级联方式访问结构体成员，即通过成员选择运算符逐级找到最底层的成员时再引用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;zhiguoxin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> temperature; <span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">char</span>  humidity;  <span class="comment">//湿度</span></span><br><span class="line">    <span class="keyword">char</span>  alcohol;   <span class="comment">//酒精浓度</span></span><br><span class="line">    <span class="keyword">int</span>   illumination;<span class="comment">//光照强度</span></span><br><span class="line">    <span class="keyword">char</span>  CO;  <span class="comment">//一氧化碳浓度</span></span><br><span class="line">    <span class="keyword">int</span>   *p;  <span class="comment">//int型的指针变量</span></span><br><span class="line">    <span class="keyword">void</span> (*fun)();</span><br><span class="line">    zhiguoxin guougo;</span><br><span class="line">    &#125;sensor;</span><br><span class="line"></span><br><span class="line">sensor sen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uart_init(<span class="number">115200</span>);<span class="comment">//串口初始化</span></span><br><span class="line">    delay_init();</span><br><span class="line"></span><br><span class="line">    sen.guougo.i=<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\r\n&quot;</span>,sen.guougo.i);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210508214709412.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508214812671.png" alt=" "></p><p>4、结构体变量可以放任何变量(<strong>结构体指针</strong>)</p><p>结构体是一个数据类型。数据类型当然也可以定义对应的指针变量啦。</p><p>就像是int 类型可以定义 int *p; 一样</p><p><img src="https://img-blog.csdnimg.cn/20210508215159419.png" alt=" "></p><p>所以当大家如果发现你的代码中结构体是通过<code>—&gt;</code>访问的话，那么这个结构体变量一定是指针类型的变量。同理如果代码中结构体是通过<code>.</code>访问的话，那么这个结构体变量就不是指针变量，而是一般的变量。</p><p><img src="https://img-blog.csdnimg.cn/20210508215434446.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210508215509432.png" alt=" "></p><p>总结：到这里结构体在单片机中的应用你已经掌握的差不多了，大家可能感觉本期讲的内容太简单了，不过只有你把这个简单的基础性知识打牢，你就会进步的更快。否则你总感觉你的代码差点意思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：听说还有好多学单片机的小伙伴不会用结构体？指针和结构体是学单片机必须要掌握的，如果你C语言掌握的不牢，单片机根本学不到精髓，只能完成一些低级的项目。看得懂结构体并且能够灵活运用结构体才能说你入门了单片机。本篇将以最通俗的方式结合STM</summary>
      
    
    
    
    
    <category term="单片机" scheme="http://liuyao-blog.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SOCKET编程|TCP、UDP网络编程</title>
    <link href="http://liuyao-blog.cn/posts/1007.html"/>
    <id>http://liuyao-blog.cn/posts/1007.html</id>
    <published>2021-08-23T08:16:49.000Z</published>
    <updated>2021-08-24T05:50:33.633Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：还在学校的朋友，如果感觉到很迷茫，不知道学什么的时候，可以上招聘网站上看看自己未来工作相关的职位的任职要求，这样就可以总结自己的一些不足、比较有针对性的去学习。不要觉得自己会玩个单片机就很NB，时刻提醒自己还很菜，要学的还有很多，不然想找高工资是没有门的，除非你家你有矿！今天来说说嵌入式必备技能之一<strong>Socket编程</strong>。</p><h2 id="一、什么是socket？"><a href="#一、什么是socket？" class="headerlink" title="一、什么是socket？"></a>一、什么是socket？</h2><p>Socket的英文原义是“孔”或“插座”。在编程中，Socket被称做 套接字，是网络通信中的一种约定。Socket编程的应用无处不在，我们平时用的QQ、微信、浏览器等程序，都与Socket编程有关。我们平时使用浏览器查资料，这个过程的技术原理是怎样的呢？</p><p><img src="https://img-blog.csdnimg.cn/20210518213030819.png" alt=" "></p><p>我们平时使用浏览器，大致就是这样的一个过程。这里有两个重要的名词： 服务端与 客户端。Socket编程的目的就是如何实现这两端之间的通信。</p><h2 id="Socket编程在嵌入式中也很重要"><a href="#Socket编程在嵌入式中也很重要" class="headerlink" title="Socket编程在嵌入式中也很重要"></a>Socket编程在嵌入式中也很重要</h2><p>Socket编程不仅仅在互联网方面很重要，在我们的嵌入式方面也是非常的重要，因为现在很多电子设备都趋向于联网。比如很多嵌入式工作的招聘要求都会有这一条要求：</p><p><img src="https://img-blog.csdnimg.cn/20210518211019845.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/2021051820582048.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210518205954624.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210518210054851.png" alt=" "></p><p>还在学校的朋友，如果感觉到很迷茫，不知道学什么的时候，可以上招聘网站上看看自己未来工作相关的职位的任职要求，这样就可以总结自己的一些不足、比较有针对性的去学习。不要觉得自己会玩个单片机就很NB，时刻提醒自己还很菜，要学的还有很多，不然想找高工资是没有门的。</p><h2 id="二、Socket编程中的几个重要概念"><a href="#二、Socket编程中的几个重要概念" class="headerlink" title="二、Socket编程中的几个重要概念"></a>二、Socket编程中的几个重要概念</h2><p>Socket编程用于解决我们 客户端与 服务端之间通信的问题。我们平时多多少少都有听过IP地址、端口、TCP协议、UDP协议等概念，这些都与Socket编程中相关，想要知道怎么用起来，当然得先了解它们的一些介绍。下面看一下这些专业术语的一些要点介绍：</p><h2 id="1、什么是IP地址？"><a href="#1、什么是IP地址？" class="headerlink" title="1、什么是IP地址？"></a>1、什么是IP地址？</h2><p>IP地址(InternetProtocolAddress)是指互联网协议地址，又译为 网际协议地址。IP地址被用来给Internet上的电脑一个编号。我们可以把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”。若计算机1知道计算机2的IP地址，则计算机1就能访问计算机2。</p><p>IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”(也就是4个字节)。IP地址通常用 点分十进制表示成(a.b.c.d)的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：点分十进IP地址(100.4.5.6)，实际上是32位二进制数(01100100.00000100.00000101.00000110)。</p><p>IP地址有 IPv4与 IPv6之分，现在用得较多的是IPv4。其中，有一个特殊的IP地址需要我们记住： 127.0.0.1，这是回送地址，即本地机，一般用来测试使用。后边我们的实例中会用到。</p><p>关于IP地址还有很多知识要点，但是对于在Socket编程中的应用，我们暂且知道这么多就可以。</p><h2 id="2、什么是TCP-IP端口？"><a href="#2、什么是TCP-IP端口？" class="headerlink" title="2、什么是TCP/IP端口？"></a>2、什么是TCP/IP端口？</h2><p>计算机1知道计算机2的IP地址，则计算机1就能访问计算机2。但是，我们要访问计算机2中的不同的应用软件，则还得需要一个信息： 端口。端口使用16bit进行编号，即其范围为： 0~ 65536。但 0~1023 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21等。</p><h2 id="3、什么是协议？"><a href="#3、什么是协议？" class="headerlink" title="3、什么是协议？"></a>3、什么是协议？</h2><p>协议（Protocol）是通信双方进行数据交互的一种约定。如TCP、UDP协议。</p><h3 id="3-1-TCP协议"><a href="#3-1-TCP协议" class="headerlink" title="3.1 TCP协议"></a>3.1 TCP协议</h3><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，数据可以准确发送，数据丢失会重发。TCP协议常用于web应用中。TCP连接（三次握手）</p><p>TCP传输起始时，客户端、服务端要完成三次数据交互工作才能建立连接，常称为三次握手。可形象比喻为如下对话：</p><blockquote><p>客户端：服务端您好，我有数据要发给你，请求您开通访问权限。<br>服务端：客户端您好，已给您开通权限，您可以发送数据了。<br>客户端：收到，谢谢。</p></blockquote><h3 id="3-2-UDP协议"><a href="#3-2-UDP协议" class="headerlink" title="3.2 UDP协议"></a>3.2 UDP协议</h3><p>UDP（User Datagram Protocol， 用户数据报协议）是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，可以保证通讯效率，传输延时小。例如视频聊天应用中用的就是UDP协议，这样可以保证及时丢失少量数据，视频的显示也不受很大影响。</p><h2 id="4、什么是协议族？"><a href="#4、什么是协议族？" class="headerlink" title="4、什么是协议族？"></a>4、什么是协议族？</h2><p>协议族是多个协议的统称。比如我们的TCP/IP协议族，其不仅仅是TCP协议、IP协议，而是多个协议的集合，其包含IP、TCP、UDP、FTP、SMTP等协议。</p><h2 id="三、socket编程的API接口"><a href="#三、socket编程的API接口" class="headerlink" title="三、socket编程的API接口"></a>三、socket编程的API接口</h2><h2 id="1、Linux下的socket-API接口"><a href="#1、Linux下的socket-API接口" class="headerlink" title="1、Linux下的socket API接口"></a>1、Linux下的socket API接口</h2><h3 id="1-创建socket：socket-函数"><a href="#1-创建socket：socket-函数" class="headerlink" title="(1)创建socket：socket()函数"></a>(1)创建socket：socket()函数</h3><p>函数原型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>af参数：af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AFINET 和 AFINET6，其前缀也可以是PF（Protocol Family），即PFINET 和 PFINET6。</p></li><li><p>type参数：type 为数据传输方式，常用的有 面向连接（ SOCK_STREAM）方式（即TCP） 和 无连接（ SOCK_DGRAM）的方式（即UDP）。</p></li><li><p>protocol参数：protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</p></li></ul><p><strong>使用示例：</strong></p><p>创建TCP套接字：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><p>创建UDP套接字：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br></pre></td></tr></table></figure><h3 id="2-绑定套接字：bind-函数"><a href="#2-绑定套接字：bind-函数" class="headerlink" title="(2)绑定套接字：bind()函数"></a>(2)绑定套接字：bind()函数</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; </span><br></pre></td></tr></table></figure><ul><li>sock参数：sock 为 socket 文件描述符。</li><li>addr参数：addr 为 sockaddr 结构体变量的指针。</li><li>addrlen参数：addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。</li></ul><p><strong>使用示例：</strong></p><p>将创建的套接字 ServerSock与本地IP 127.0.0.1、端口 1314进行绑定：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建服务端socket */</span></span><br><span class="line"><span class="keyword">int</span> ServerSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">/* 设置服务端信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ServerSockAddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr)); <span class="comment">// 给结构体ServerSockAddr清零</span></span><br><span class="line">ServerSockAddr.sin_family = PF_INET;  <span class="comment">// 使用IPv4地址</span></span><br><span class="line">ServerSockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">// 本机IP地址</span></span><br><span class="line">ServerSockAddr.sin_port = htons(<span class="number">1314</span>); <span class="comment">// 端口</span></span><br><span class="line"><span class="comment">/* 绑定套接字 */</span></span><br><span class="line">bind(ServerSock, (SOCKADDR*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br></pre></td></tr></table></figure><p>其中 structsockaddr_in类型的结构体变量用于保存IPv4的IP信息。若是IPv6，则有对应的结构体：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;    <span class="comment">// 地址类型，取值为AF_INET6</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;        <span class="comment">// 16位端口号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;     <span class="comment">// IPv6流信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>  <span class="comment">// 具体的IPv6地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;     <span class="comment">// 接口范围ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-建立连接：connect-函数"><a href="#3-建立连接：connect-函数" class="headerlink" title="(3)建立连接：connect()函数"></a>(3)建立连接：connect()函数</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;  </span><br></pre></td></tr></table></figure><p>参数与 bind()的参数类似。</p><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ClientSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">connect(ClientSock, (SOCKADDR*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br></pre></td></tr></table></figure><h3 id="4-监听：listen-函数"><a href="#4-监听：listen-函数" class="headerlink" title="(4)监听：listen()函数"></a>(4)监听：listen()函数</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>sock参数：sock 为需要进入监听状态的套接字。<br>backlog参数：backlog 为请求队列的最大长度。</p><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进入监听状态 */</span></span><br><span class="line">listen(ServerSock, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="5-接收请求：accept-函数"><a href="#5-接收请求：accept-函数" class="headerlink" title="(5)接收请求：accept()函数"></a>(5)接收请求：accept()函数</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sock, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sock参数：sock 为服务器端套接字。</li><li>addr参数：addr 为 sockaddr_in 结构体变量。</li><li>addrlen参数：addrlen 为参数 addr 的长度，可由 sizeof() 求得。</li><li>返回值：一个新的套接字，用于与客户端通信。</li></ul><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 监听客户端请求，accept函数返回一个新的套接字，发送和接收都是用这个套接字 */</span></span><br><span class="line"><span class="keyword">int</span> ClientSock = accept(ServerSock, (SOCKADDR*)&amp;ClientAddr, &amp;len);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-关闭：close-函数"><a href="#6-关闭：close-函数" class="headerlink" title="(6)关闭：close()函数"></a>(6)关闭：close()函数</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>fd：要关闭的文件描述符。</li></ul><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">close(ServerSock);</span><br></pre></td></tr></table></figure><h3 id="7-数据的接收和发送"><a href="#7-数据的接收和发送" class="headerlink" title="(7)数据的接收和发送"></a>(7)数据的接收和发送</h3><p>数据收发函数有几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>函数原型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>这里介绍一下recv()/send()、recvfrom()/sendto()。</p><p><strong>recv()函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数：sockfd为要接收数据的套接字。</li><li>buf参数：buf 为要接收的数据的缓冲区地址。</li><li>len参数：len 为要接收的数据的字节数。</li><li>flags参数：flags 为接收数据时的选项，常设为0。</li></ul><p><strong>send()函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数：sockfd为要发送数据的套接字。</li><li>buf参数：buf 为要发送的数据的缓冲区地址。</li><li>len参数：len 为要发送的数据的字节数。</li><li>flags参数：flags 为发送数据时的选项，常设为0。</li></ul><p><strong>recvfrom()函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, struct sockadr *from, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sock：用于接收UDP数据的套接字；</li><li>buf：保存接收数据的缓冲区地址；</li><li>nbytes：可接收的最大字节数（不能超过buf缓冲区的大小）；</li><li>flags：可选项参数，若没有可传递0；</li><li>from：存有发送端地址信息的sockaddr结构体变量的地址；</li><li>addrlen：保存参数 from 的结构体变量长度的变量地址值。</li></ul><p><strong>sendto()函数：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, struct sockaddr *to, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sock：用于传输UDP数据的套接字；</li><li>buf：保存待传输数据的缓冲区地址；</li><li>nbytes：带传输数据的长度（以字节计）；</li><li>flags：可选项参数，若没有可传递0；</li><li>to：存有目标地址信息的 sockaddr 结构体变量的地址；</li><li>addrlen：传递给参数 to 的地址值结构体变量的长度。</li></ul><h2 id="2、windows下的socket-API接口"><a href="#2、windows下的socket-API接口" class="headerlink" title="2、windows下的socket API接口"></a>2、windows下的socket API接口</h2><p>跟Linux下的差不多：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(SOCKET sock, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(SOCKET sock, <span class="keyword">const</span> struct sockaddr *serv_addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(SOCKET sock, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET sock, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closesocket</span><span class="params">( SOCKET s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(SOCKET sock, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(SOCKET sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *from, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(SOCKET sock, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockadr *to, <span class="keyword">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3、socket编程过程图"><a href="#3、socket编程过程图" class="headerlink" title="3、socket编程过程图"></a>3、socket编程过程图</h2><h3 id="3-1-TCP通信socket编程过程"><a href="#3-1-TCP通信socket编程过程" class="headerlink" title="3.1 TCP通信socket编程过程"></a>3.1 TCP通信socket编程过程</h3><p><img src="https://img-blog.csdnimg.cn/20210518215009668.png" alt=" "></p><h3 id="3-2-UDP通信socket编程过程"><a href="#3-2-UDP通信socket编程过程" class="headerlink" title="3.2 UDP通信socket编程过程"></a>3.2 UDP通信socket编程过程</h3><p><img src="https://img-blog.csdnimg.cn/20210518215412703.png" alt=" "></p><h2 id="四、socket的应用实例"><a href="#四、socket的应用实例" class="headerlink" title="四、socket的应用实例"></a>四、socket的应用实例</h2><h2 id="1、基于TCP的本地客户端、服务端信息交互实例"><a href="#1、基于TCP的本地客户端、服务端信息交互实例" class="headerlink" title="1、基于TCP的本地客户端、服务端信息交互实例"></a>1、基于TCP的本地客户端、服务端信息交互实例</h2><p>本例的例子实现的功能为：本地TCP客户端往本地TCP服务端发送数据，TCP服务端收到数据则会打印输出，同时把原数据返回给TCP客户端。这个例子类似于我们在做单片机的串口实验时，串口上位机往我们的单片机发送数据，单片机收到数据则把该数据原样返回给上位机。</p><h3 id="1-windows的程序"><a href="#1-windows的程序" class="headerlink" title="(1)windows的程序"></a>(1)windows的程序</h3><h4 id="服务端程序tcp-server-c"><a href="#服务端程序tcp-server-c" class="headerlink" title="服务端程序tcp_server.c"></a>服务端程序tcp_server.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wd;</span><br><span class="line">    SOCKET ServerSock, ClientSock;</span><br><span class="line">    <span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    SOCKADDR ClientAddr;</span><br><span class="line">    SOCKADDR_IN ServerSockAddr;</span><br><span class="line">    <span class="keyword">int</span> addr_size = <span class="number">0</span>, recv_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化操作sock需要的DLL */</span></span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;wd);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建服务端socket */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (ServerSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务端信息 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr)); <span class="comment">// 给结构体ServerSockAddr清零</span></span><br><span class="line">    ServerSockAddr.sin_family = AF_INET;  <span class="comment">// 使用IPv4地址</span></span><br><span class="line">    ServerSockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">// 本机IP地址</span></span><br><span class="line">    ServerSockAddr.sin_port = htons(<span class="number">1314</span>);  <span class="comment">// 端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定套接字 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(ServerSock, (SOCKADDR*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(SOCKADDR)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 进入监听状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == listen(ServerSock, <span class="number">10</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr_size = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 监听客户端请求，accept函数返回一个新的套接字，发送和接收都是用这个套接字 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == (ClientSock = accept(ServerSock, (SOCKADDR*)&amp;ClientAddr, &amp;addr_size)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 接受客户端的返回数据 */</span></span><br><span class="line">        <span class="keyword">int</span> recv_len = recv(ClientSock, Buf, BUF_LEN, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 发送数据到客户端 */</span></span><br><span class="line">        send(ClientSock, Buf, recv_len, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 关闭客户端套接字 */</span></span><br><span class="line">        closesocket(ClientSock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果有退出循环的条件，这里还需要清除对socket库的使用*/</span></span><br><span class="line">    <span class="comment">/* 关闭服务端套接字 */</span></span><br><span class="line">    <span class="comment">//closesocket(ServerSock);</span></span><br><span class="line">    <span class="comment">/* WSACleanup();*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端程序tcp-client-c"><a href="#客户端程序tcp-client-c" class="headerlink" title="客户端程序tcp_client.c"></a>客户端程序tcp_client.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA wd;</span><br><span class="line">SOCKET ClientSock;</span><br><span class="line"><span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">SOCKADDR_IN  ServerSockAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化操作sock需要的DLL */</span></span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;wd);  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向服务器发起请求 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr));  </span><br><span class="line">ServerSockAddr.sin_family = AF_INET;</span><br><span class="line">ServerSockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">ServerSockAddr.sin_port = htons(<span class="number">1314</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建客户端socket */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (ClientSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == connect(ClientSock, (SOCKADDR*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(SOCKADDR)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串，发送给服务端：&quot;</span>);</span><br><span class="line">    gets(Buf);</span><br><span class="line">    <span class="comment">/* 发送数据到服务端 */</span></span><br><span class="line">    send(ClientSock, Buf, <span class="built_in">strlen</span>(Buf), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 接受服务端的返回数据 */</span></span><br><span class="line">    recv(ClientSock, Buf, BUF_LEN, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">    closesocket(ClientSock);   <span class="comment">// 关闭套接字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// WSACleanup();  /*如果有退出循环的条件，这里还需要清除对socket库的使用*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的IP地址概念那一部分中，有强调<code>127.0.0.1</code>这个IP是一个特殊的IP地址，这是<strong>回送地址，即本地机，一般用来测试使用</strong>。这个例子中我们就用到了。此外，端口我们设置为<code>1314</code>，这是随意设置的，只要范围在<code>1024~65536</code>之间就可以。</p><p>在这里我是用记事本Notepad3写得程序，在windows下用命令行来编译运行程序的。首先要安装Notepad3软件，然后要安装gcc编译器<code>MinGW</code>。本文使用的是gcc编译器编译，编译命令如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc tcp_server.c -o tcp_server.exe -lwsock32</span><br><span class="line">gcc tcp_client.c -o tcp_client.exe -lwsock32</span><br></pre></td></tr></table></figure><p>这里必须要加 -lwsock32这个参数用于链接windows下socket编程必须的winsock2这个库。若是使用集成开发环境，则需要把 wsock32.lib放在工程目录下，并在我们代码中 <code>#include&lt;winsock2.h&gt;</code> 下面加上一行 <code>#pragmacomment(lib,&quot;ws2_32.lib&quot;)</code>代码（这种情况本人未验证，有兴趣的朋友可尝试）。</p><p><strong>实验现象：</strong></p><p>先启动服务端程序<code>tcp_server.exe</code>，再启动客户端程序<code>tcp_client.exe</code>，并在客户端中输入字符串，则当服务端会接收到字符串时会打印输出，与此同时也会往客户端返回相同的数据：</p><p><img src="https://img-blog.csdnimg.cn/20210516222658250.png" alt=" "></p><h3 id="2-Linux的程序"><a href="#2-Linux的程序" class="headerlink" title="(2)Linux的程序"></a>(2)Linux的程序</h3><p>在linux下，“一切都是文件”，所以这里我们的套接字也当做文件来看待。</p><h4 id="服务端程序linux-tcp-server-c"><a href="#服务端程序linux-tcp-server-c" class="headerlink" title="服务端程序linux_tcp_server.c"></a>服务端程序linux_tcp_server.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ServerFd, ClientFd;<span class="comment">//定义服务端和客户端的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ServerSockAddr</span>;</span>  <span class="comment">//定义服务端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ClientAddr</span>;</span><span class="comment">//定义客户端socket地址</span></span><br><span class="line">    <span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义接受缓冲区的buf</span></span><br><span class="line">    <span class="keyword">int</span> addr_len = <span class="number">0</span>, recv_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> optval = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建服务端文件描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (ServerFd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务端信息 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr)); <span class="comment">// 给结构体ServerSockAddr清零</span></span><br><span class="line">    ServerSockAddr.sin_family = AF_INET;  <span class="comment">// 使用IPv4地址</span></span><br><span class="line">    ServerSockAddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">// 自动获取IP地址</span></span><br><span class="line">    ServerSockAddr.sin_port = htons(<span class="number">6666</span>);  <span class="comment">// 端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址和端口号可以重复使用  </span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(ServerFd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span>(optval)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;setsockopt error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定操作，绑定前加上上面的socket属性可重复使用地址 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(ServerFd, (struct sockaddr*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(struct sockaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 进入监听状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (listen(ServerFd, <span class="number">10</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr_len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 监听客户端请求，accept函数返回一个新的套接字，发送和接收都是用这个套接字 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == (ClientFd = accept(ServerFd, (struct sockaddr*)&amp;ClientAddr, &amp;addr_len)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;accept error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 接受客户端的返回数据 */</span></span><br><span class="line">        <span class="keyword">if</span> ((recv_len = recv(ClientFd, Buf, BUF_LEN, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 发送数据到客户端 */</span></span><br><span class="line">        send(ClientFd, Buf, recv_len, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 关闭客户端套接字 */</span></span><br><span class="line">        close(ClientFd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端程序linux-tcp-client-c"><a href="#客户端程序linux-tcp-client-c" class="headerlink" title="客户端程序linux_tcp_client.c"></a>客户端程序linux_tcp_client.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ClientFd;</span><br><span class="line">    <span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">ServerSockAddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向服务器发起请求 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr));  </span><br><span class="line">    ServerSockAddr.sin_family = AF_INET;</span><br><span class="line">    ServerSockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    ServerSockAddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建客户端socket */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == (ClientFd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 连接 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == connect(ClientFd, (struct sockaddr*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(ServerSockAddr)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串，发送给服务端：&quot;</span>);</span><br><span class="line">        gets(Buf);</span><br><span class="line">        <span class="comment">/* 发送数据到服务端 */</span></span><br><span class="line">        send(ClientFd, Buf, <span class="built_in">strlen</span>(Buf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接受服务端的返回数据 */</span></span><br><span class="line">        recv(ClientFd, Buf, BUF_LEN, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">        close(ClientFd);   <span class="comment">// 关闭套接字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux下编译就不需要添加 -lwsock32参数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc linux_tcp_server.c -o linux_tcp_server</span><br><span class="line">gcc linux_tcp_client.c -o linux_tcp_client</span><br></pre></td></tr></table></figure><h2 id="2、基于UDP的本地客户端、服务端信息交互实例"><a href="#2、基于UDP的本地客户端、服务端信息交互实例" class="headerlink" title="2、基于UDP的本地客户端、服务端信息交互实例"></a>2、基于UDP的本地客户端、服务端信息交互实例</h2><h3 id="1-windows的程序-1"><a href="#1-windows的程序-1" class="headerlink" title="(1) windows的程序"></a>(1) windows的程序</h3><h4 id="服务端程序udp-server-c"><a href="#服务端程序udp-server-c" class="headerlink" title="服务端程序udp_server.c"></a>服务端程序udp_server.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wd;</span><br><span class="line">    SOCKET ServerSock;</span><br><span class="line">    <span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    SOCKADDR ClientAddr;</span><br><span class="line">    SOCKADDR_IN ServerSockAddr;</span><br><span class="line">    <span class="keyword">int</span> addr_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化操作sock需要的DLL */</span></span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;wd);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建服务端socket */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (ServerSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务端信息 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr)); <span class="comment">// 给结构体ServerSockAddr清零</span></span><br><span class="line">    ServerSockAddr.sin_family = AF_INET;  <span class="comment">// 使用IPv4地址</span></span><br><span class="line">    ServerSockAddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 自动获取IP地址</span></span><br><span class="line">    ServerSockAddr.sin_port = htons(<span class="number">1314</span>);  <span class="comment">// 端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定套接字 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (bind(ServerSock, (SOCKADDR*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(SOCKADDR))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    addr_size = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 接受客户端的返回数据 */</span></span><br><span class="line">        <span class="keyword">int</span> str_len = recvfrom(ServerSock, Buf, BUF_LEN, <span class="number">0</span>, &amp;ClientAddr, &amp;addr_size);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 发送数据到客户端 */</span></span><br><span class="line">        sendto(ServerSock, Buf, str_len, <span class="number">0</span>, &amp;ClientAddr, addr_size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果有退出循环的条件，这里还需要清除对socket库的使用*/</span></span><br><span class="line">    <span class="comment">/* 关闭服务端套接字 */</span></span><br><span class="line">    <span class="comment">//closesocket(ServerSock);</span></span><br><span class="line">    <span class="comment">/* WSACleanup();*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端程序udp-client-c"><a href="#客户端程序udp-client-c" class="headerlink" title="客户端程序udp_client.c"></a>客户端程序udp_client.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wd;</span><br><span class="line">    SOCKET ClientSock;</span><br><span class="line">    <span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    SOCKADDR ServerAddr;</span><br><span class="line">    SOCKADDR_IN  ServerSockAddr;</span><br><span class="line">    <span class="keyword">int</span> ServerAddrLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化操作sock需要的DLL */</span></span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;wd);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建客户端socket */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (ClientSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向服务器发起请求 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr));  </span><br><span class="line">    ServerSockAddr.sin_family = PF_INET;</span><br><span class="line">    ServerSockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    ServerSockAddr.sin_port = htons(<span class="number">1314</span>);</span><br><span class="line"></span><br><span class="line">    ServerAddrLen = <span class="keyword">sizeof</span>(ServerAddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串，发送给服务端：&quot;</span>);</span><br><span class="line">        gets(Buf);</span><br><span class="line">        <span class="comment">/* 发送数据到服务端 */</span></span><br><span class="line">        sendto(ClientSock, Buf, <span class="built_in">strlen</span>(Buf), <span class="number">0</span>, (struct sockaddr*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(ServerSockAddr));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接受服务端的返回数据 */</span></span><br><span class="line">        recvfrom(ClientSock, Buf, BUF_LEN, <span class="number">0</span>, &amp;ServerAddr, &amp;ServerAddrLen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(ClientSock);   <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="comment">// WSACleanup();  /*如果有退出循环的条件，这里还需要清除对socket库的使用*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Linux下的程序"><a href="#2-Linux下的程序" class="headerlink" title="(2)Linux下的程序"></a>(2)Linux下的程序</h3><h4 id="服务端程序linux-udp-server-c"><a href="#服务端程序linux-udp-server-c" class="headerlink" title="服务端程序linux_udp_server.c"></a>服务端程序linux_udp_server.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ServerFd, ClientFd;<span class="comment">//定义服务端和客户端的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ServerSockAddr</span>;</span>  <span class="comment">//定义服务端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ClientAddr</span>;</span><span class="comment">//定义客户端socket地址</span></span><br><span class="line">    <span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;<span class="comment">//定义接受缓冲区的buf</span></span><br><span class="line">    <span class="keyword">int</span> addr_len = <span class="number">0</span>, recv_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> optval = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建服务端文件描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (ServerFd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置服务端信息 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr)); <span class="comment">// 给结构体ServerSockAddr清零</span></span><br><span class="line">    ServerSockAddr.sin_family = AF_INET;  <span class="comment">// 使用IPv4地址</span></span><br><span class="line">    ServerSockAddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">// 自动获取IP地址</span></span><br><span class="line">    ServerSockAddr.sin_port = htons(<span class="number">6666</span>);  <span class="comment">// 端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址和端口号可以重复使用  </span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(ServerFd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span>(optval)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;setsockopt error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定操作，绑定前加上上面的socket属性可重复使用地址 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(ServerFd, (struct sockaddr*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(struct sockaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 进入监听状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (listen(ServerFd, <span class="number">10</span>)))<span class="comment">//10表示可以同时连接客户端的数量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr_len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 监听客户端请求，accept函数返回一个新的套接字，发送和接收都是用这个套接字 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == (ClientFd = accept(ServerFd, (struct sockaddr*)&amp;ClientAddr, &amp;addr_len)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;accept error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 接受客户端的返回数据 */</span></span><br><span class="line">        <span class="keyword">if</span> ((recv_len = recv(ClientFd, Buf, BUF_LEN, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 发送数据到客户端 */</span></span><br><span class="line">        send(ClientFd, Buf, recv_len, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 关闭客户端套接字 */</span></span><br><span class="line">        close(ClientFd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端程序linux-udp-client-c"><a href="#客户端程序linux-udp-client-c" class="headerlink" title="客户端程序linux_udp_client.c"></a>客户端程序linux_udp_client.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN  100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ClientFd;</span><br><span class="line">    <span class="keyword">char</span> Buf[BUF_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">ServerSockAddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向服务器发起请求 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ServerSockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ServerSockAddr));  </span><br><span class="line">    ServerSockAddr.sin_family = AF_INET;</span><br><span class="line">    ServerSockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    ServerSockAddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建客户端socket */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == (ClientFd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 连接 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == connect(ClientFd, (struct sockaddr*)&amp;ServerSockAddr, <span class="keyword">sizeof</span>(ServerSockAddr)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串，发送给服务端：&quot;</span>);</span><br><span class="line">        gets(Buf);</span><br><span class="line">        <span class="comment">/* 发送数据到服务端 */</span></span><br><span class="line">        send(ClientFd, Buf, <span class="built_in">strlen</span>(Buf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 接受服务端的返回数据 */</span></span><br><span class="line">        recv(ClientFd, Buf, BUF_LEN, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务端发送过来的数据为：%s\n&quot;</span>, Buf);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(Buf, <span class="number">0</span>, BUF_LEN);   <span class="comment">// 重置缓冲区</span></span><br><span class="line">        close(ClientFd);   <span class="comment">// 关闭套接字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：还在学校的朋友，如果感觉到很迷茫，不知道学什么的时候，可以上招聘网站上看看自己未来工作相关的职位的任职要求，这样就可以总结自己的一些不足、比较有针对性的去学习。不要觉得自己会玩个单片机就很NB，时刻提醒自己还很菜，要学的还有很多，不然</summary>
      
    
    
    
    <category term="SOCKET编程" scheme="http://liuyao-blog.cn/categories/SOCKET%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="SOCKET编程" scheme="http://liuyao-blog.cn/tags/SOCKET%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用STM32、FPGA、Linux点亮LED的异同</title>
    <link href="http://liuyao-blog.cn/posts/1005.html"/>
    <id>http://liuyao-blog.cn/posts/1005.html</id>
    <published>2021-08-23T07:53:50.000Z</published>
    <updated>2021-08-24T05:50:22.413Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：不知道小伙伴们点亮过多少板子的LED灯，有很多小伙伴留言说讲一下stm32、fpga、liunx他们之间有什么不同，不同点很多，口说无凭，今天就来点亮一下stm32、fpga和liunx板子的led灯，大家大致看一下点灯流程和点灯环境以及点灯流程，就能大概的了解一下三者的区别，可以有选择的去学习！</p><p><img src="https://files.mdnice.com/user/3658/3eb0987c-8bf7-476e-9064-c85ddbbea95f.gif" alt=" "></p><h2 id="一、使用STM32点亮LED灯"><a href="#一、使用STM32点亮LED灯" class="headerlink" title="一、使用STM32点亮LED灯"></a>一、使用STM32点亮LED灯</h2><p>STM32从字面上来理解ST是意法半导体，M是Microelectronics的缩写，32 表示32位，合起来理解，STM32就是指ST公司开发的32位微控制器。在如今的32 位控制器当中，<strong>STM32可以说是最璀璨的新星，它受宠若娇，大受工程师和市场的青睐，无芯能出其右</strong>。首先使用STM32电亮一个led灯，大家现在回过头来看是不是非常的简单。</p><p>STM32初始化流程</p><p>1、使能指定GPIO的时钟。</p><p>2、初始化GPIO，比如输出功能、上拉、速度等等。</p><p>3、STM32有的IO可以作为其它外设引脚，也就是IO复用，如果要将IO作为其它外设引脚使用的话就需要设置 IO 的复用功能。</p><p>4、最后设置GPIO输出高电平或者低电平。</p><h2 id="1、新建工程"><a href="#1、新建工程" class="headerlink" title="1、新建工程"></a>1、新建工程</h2><p><img src="https://img-blog.csdnimg.cn/20210703160023888.png" alt=" "></p><h2 id="2、代码编写"><a href="#2、代码编写" class="headerlink" title="2、代码编写"></a>2、代码编写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LED IO初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);<span class="comment">//使能GPIOF时钟</span></span><br><span class="line">  <span class="comment">//GPIOF9,F10初始化设置</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;<span class="comment">//LED0和LED1对应IO口</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;<span class="comment">//普通输出模式</span></span><br><span class="line">  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<span class="comment">//推挽输出</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;<span class="comment">//100MHz</span></span><br><span class="line">  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<span class="comment">//上拉</span></span><br><span class="line">  GPIO_Init(GPIOF, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIO</span></span><br><span class="line">  GPIO_SetBits(GPIOF,GPIO_Pin_9 | GPIO_Pin_10);<span class="comment">//GPIOF9,F10设置高，灯灭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、编译代码"><a href="#3、编译代码" class="headerlink" title="3、编译代码"></a>3、编译代码</h2><p><img src="https://img-blog.csdnimg.cn/20210703160113436.png" alt=" "></p><h2 id="4、配置下载器"><a href="#4、配置下载器" class="headerlink" title="4、配置下载器"></a>4、配置下载器</h2><p><img src="https://img-blog.csdnimg.cn/20210703160342187.png" alt=" "></p><h2 id="烧录代码"><a href="#烧录代码" class="headerlink" title="烧录代码"></a>烧录代码</h2><p><img src="https://img-blog.csdnimg.cn/20210703160830212.png" alt=" "></p><h2 id="二、使用FPGA点亮LED灯"><a href="#二、使用FPGA点亮LED灯" class="headerlink" title="二、使用FPGA点亮LED灯"></a>二、使用FPGA点亮LED灯</h2><p>FPGA(Field Programmable Gate Array，简称 FPGA)，译文：现场可编程门阵列，一种主要以数字电路为主的集成芯片，于1985年由Xilinx创始人之一 Ross Freeman发明，属于可编程逻辑器件PLD(Programmable Logic Device)的一种。真正意义上的第一颗FPGA芯片XC2064为Xilinx所发明，这个时间差不多比著名的摩尔定律晚20年左右，但是FPGA一经发明，后续的发展速度之快，超出大多数人的想象。</p><p>计数器是在FPGA设计中最常用的一种<strong>时序逻</strong>辑电路，根据计数器的计数值我们可以精确的计算出FPGA内部各种信号之间的时间关系，每个信号何时拉高、何时拉低、拉高多久、拉低多久都可以由计数器实现精确的控制。而让<strong>计数器计数的是由外部晶振产生的时钟</strong>，所以可以比较精准的控制具体需要计数的时间。计数器一般都是从0开始计数，计数到我们需要的值或者计数满溢出后清零，并可以进行不断的循环。</p><p>本例我们让计数器计数1s时间间隔，来实现led灯每隔1s闪烁一次的效果。</p><p><img src="https://img-blog.csdnimg.cn/20210627161523104.png" alt=" "><br><img src="https://img-blog.csdnimg.cn/20210627161546503.png" alt=" "><br><img src="https://img-blog.csdnimg.cn/2021062716182523.png" alt=" "><br><img src="https://img-blog.csdnimg.cn/20210627161842463.png" alt=" "></p><h2 id="2、RTL代码的编写"><a href="#2、RTL代码的编写" class="headerlink" title="2、RTL代码的编写"></a>2、RTL代码的编写</h2><p>开始RTL代码的编写，RTL代码编写出的模块叫RTL模块(后文中也称<strong>功能模块</strong>、可综合模块)。之所以叫RTL代码是因为用Verilog HDL在Resistances Transistors Logic（寄存器传输级逻辑）来描述硬件电路，<strong>RTL代码能够综合出真实的电路以实现我们设计的功能</strong>，区别于不可综合的仿真代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`timescale  <span class="number">1</span>ns/<span class="number">1</span>ns</span><br><span class="line"><span class="comment">//带标志信号的计数器</span></span><br><span class="line"><span class="keyword">module</span>  counter</span><br><span class="line">#(</span><br><span class="line">    parameter   CNT_MAX = <span class="number">25&#x27;</span>d24_999_999</span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    input   wire    sys_clk     ,   <span class="comment">//系统时钟50Mhz</span></span><br><span class="line">    input   wire    sys_rst_n   ,   <span class="comment">//全局复位</span></span><br><span class="line">    output  reg     led_out         <span class="comment">//输出控制led灯</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg     [<span class="number">24</span>:<span class="number">0</span>]  cnt;       <span class="comment">//经计算得需要25位宽的寄存器才够500ms</span></span><br><span class="line">reg             cnt_flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cnt:计数器计数,当计数到CNT_MAX的值时清零</span></span><br><span class="line">always@(posedge sys_clk <span class="keyword">or</span> negedge sys_rst_n)</span><br><span class="line">    <span class="keyword">if</span>(sys_rst_n == <span class="number">1&#x27;b</span>0)</span><br><span class="line">        cnt &lt;= <span class="number">25&#x27;b</span>0;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">if</span>(cnt &lt; CNT_MAX)</span><br><span class="line">         cnt &lt;= cnt + <span class="number">1&#x27;b</span>1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       cnt &lt;= <span class="number">25&#x27;b</span>0;</span><br><span class="line"><span class="comment">//cnt_flag:计数到最大值产生的标志信号</span></span><br><span class="line">always@(posedge sys_clk <span class="keyword">or</span> negedge sys_rst_n)</span><br><span class="line">    <span class="keyword">if</span>(sys_rst_n == <span class="number">1&#x27;b</span>0)</span><br><span class="line">        cnt_flag &lt;= <span class="number">1&#x27;b</span>0;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">if</span>(cnt == CNT_MAX - <span class="number">1&#x27;b</span>1)</span><br><span class="line">        cnt_flag &lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_flag &lt;= <span class="number">1&#x27;b</span>0;</span><br><span class="line"><span class="comment">//led_out:输出控制一个LED灯,每当计数满标志信号有效时取反</span></span><br><span class="line">always@(posedge sys_clk <span class="keyword">or</span> negedge sys_rst_n)</span><br><span class="line">    <span class="keyword">if</span>(sys_rst_n == <span class="number">1&#x27;b</span>0)</span><br><span class="line">        led_out &lt;= <span class="number">1&#x27;b</span>0;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">if</span>(cnt_flag == <span class="number">1&#x27;b</span>1)</span><br><span class="line">        led_out &lt;= ~led_out;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="3、代码的分析和综合"><a href="#3、代码的分析和综合" class="headerlink" title="3、代码的分析和综合"></a>3、代码的分析和综合</h2><p><img src="https://img-blog.csdnimg.cn/20210627165651197.png" alt=" "></p><h2 id="4、-查看RTL视图"><a href="#4、-查看RTL视图" class="headerlink" title="4、 查看RTL视图"></a>4、 查看RTL视图</h2><p><img src="https://img-blog.csdnimg.cn/20210627165745627.png" alt=" "></p><h2 id="5、Testbench代码的编写"><a href="#5、Testbench代码的编写" class="headerlink" title="5、Testbench代码的编写"></a>5、Testbench代码的编写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`timescale  <span class="number">1</span>ns/<span class="number">1</span><span class="function">ns</span></span><br><span class="line"><span class="function"><span class="keyword">module</span>  <span class="title">tb_counter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//wire  define</span></span><br><span class="line">wire            led_out     ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reg   define</span></span><br><span class="line">reg             sys_clk     ;</span><br><span class="line">reg             sys_rst_n   ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化系统时钟、全局复位</span></span><br><span class="line">initial begin</span><br><span class="line">    sys_clk    = <span class="number">1&#x27;b</span>1;</span><br><span class="line">    sys_rst_n &lt;= <span class="number">1&#x27;b</span>0;</span><br><span class="line">    #<span class="number">20</span></span><br><span class="line">    sys_rst_n &lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhz</span></span><br><span class="line">always #<span class="number">10</span> sys_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">    $timeformat(<span class="number">-9</span>, <span class="number">0</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    $monitor(<span class="string">&quot;@time %t: led_out=%b&quot;</span>, $time, led_out);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- counter_inst --------------</span></span><br><span class="line">counter</span><br><span class="line">#(</span><br><span class="line">    .CNT_MAX    (<span class="number">25&#x27;</span>d24     ) </span><br><span class="line">)</span><br><span class="line">counter_inst</span><br><span class="line">(</span><br><span class="line">    .sys_clk    (sys_clk    ),  <span class="comment">//input     sys_clk</span></span><br><span class="line">    .sys_rst_n  (sys_rst_n  ),  <span class="comment">//input     sys_rst_n</span></span><br><span class="line"></span><br><span class="line">    .led_out    (led_out    )   <span class="comment">//output    led_out</span></span><br><span class="line">);</span><br><span class="line">endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、ModelSim仿真波形"><a href="#6、ModelSim仿真波形" class="headerlink" title="6、ModelSim仿真波形"></a>6、ModelSim仿真波形</h2><p><img src="https://img-blog.csdnimg.cn/20210627170314595.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210627170625819.png" alt=" "></p><h2 id="7、上板验证"><a href="#7、上板验证" class="headerlink" title="7、上板验证"></a>7、上板验证</h2><p><img src="https://img-blog.csdnimg.cn/20210627171113354.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210627171206257.png" alt=" "></p><p>程序下载完毕后，会看到板卡LED0不断闪烁，时间间隔为1秒。</p><p><img src="https://img-blog.csdnimg.cn/20210703155654664.png" alt=" "></p><h2 id="三、使用I-MX6ULL-IO点亮LED"><a href="#三、使用I-MX6ULL-IO点亮LED" class="headerlink" title="三、使用I.MX6ULL IO点亮LED"></a>三、使用I.MX6ULL IO点亮LED</h2><p>嵌入式linux学习者大体可以分为两类，一类是进阶用户，主要指已经有大量mcu工作经验的开发者， 他们希望进阶到更有难度，薪资更高的mpu开发中去。另一类则是学生用户，主要是刚开始接触嵌入式开发的大学生群体。</p><p>I.MX应用处理器包括I.MX8、I.MX7、I.MX6及I.MX28系列，被广泛应用于工业控制、汽车电子领域，久经市场考验。而且它的产品线非常丰富，用户熟悉其中一款产品后就能非常方便地迁移至不同的平台。</p><p>一般拿到一款全新的芯片，第一个要做的事情的就是驱动其GPIO，控制其GPIO输出高低电平，我们学习I.MX6U也一样的，先来学习一下I.MX6U的GPIO。在学习I.MX6U的GPIO之前，我们可以对比一下STM32的GPIO初始化(如果没有学过 STM32 就不用回顾了)，我们以最常见的STM32F103为例来看一下STM32的GPIO初始化，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//使能 PB 端口时钟</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//PB5 端口配置</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//推挽输出</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//IO 口速度</span></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure); <span class="comment">//根据设定参数初始化 GPIOB.5</span></span><br><span class="line">    GPIO_SetBits(GPIOB,GPIO_Pin_5); <span class="comment">//PB.5 输出高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STM32初始化流程</p><p>1、使能指定GPIO的时钟。</p><p>2、初始化 GPIO，比如输出功能、上拉、速度等等。</p><p>3、STM32 有的 IO 可以作为其它外设引脚，也就是 IO 复用，如果要将 IO 作为其它外设引脚使用的话就需要设置 IO 的复用功能。</p><p>4、最后设置GPIO输出高电平或者低电平。</p><p>I.MX6U的GPIO一共有5组：<code>GPIO1、GPIO2、GPIO3、GPIO4和GPIO5</code>，其中GPIO1有32个IO，GPIO2有22个IO，GPIO3有29个IO、GPIO4有29个IO，GPIO5最少，只有12个IO，这样一共有<code>124个GPIO</code>。</p><p>I.MX6ULL IO初始化流程</p><p>1、使能时钟，<code>CCGR0—CCGR6</code>这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置<code>CCGR0~CCGR6这7</code>个寄存器全部为<code>0XFFFFFFFF</code>，相当于使能所有外设时钟。</p><p>2、IO复用，将寄存器<code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</code>的<code>bit3~0</code>设置为<code>0101=5</code>，这样<code>GPIO1_IO03</code>就复用为<code>GPIO</code>。</p><p>3、寄存器<code>IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03</code>是设置<code>GPIO1_IO03</code>的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。</p><p>4、配置<code>GPIO功</code>能，设置输入输出。设置<code>GPIO1_DR</code>寄存器bit3为1，也就是设置为输出模式。设置<code>GPIO1_DR</code>寄存器的<code>bit3</code>，为1表示输出高电平，为0表示输出低电平。</p><p>汇编由一条一条指令构成，指令就涉及到汇编指令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Int a，b;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure><p>假设a地址为0X20，b地址为0x30</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LDR R0, =0X30</span><br><span class="line">LDR R1, [R0]</span><br><span class="line">LDR R0, =0X20</span><br><span class="line">STR R1, [R0]</span><br></pre></td></tr></table></figure><p>我们在使用汇编编写驱动的时候最常用的就是<code>LDR</code>和<code>STR</code>这两个指令。</p><h2 id="1新建工程"><a href="#1新建工程" class="headerlink" title="1新建工程"></a>1新建工程</h2><p>新建工程文件夹<br><img src="https://img-blog.csdnimg.cn/20210702195345707.png" alt="新建裸机驱动文件夹"></p><p><img src="https://img-blog.csdnimg.cn/2021070219562147.png" alt="新建LED灯文件夹"></p><h2 id="2、在VSCode中编写代码"><a href="#2、在VSCode中编写代码" class="headerlink" title="2、在VSCode中编写代码"></a>2、在VSCode中编写代码</h2><p>ubuntu中我们使用的是VScode编辑器来写代码，跟在windows中新建项目一样，新建项目、保存工作区，然后编写代码。</p><p><img src="https://img-blog.csdnimg.cn/20210702213944379.png" alt=" "></p><h2 id="3、编写代码"><a href="#3、编写代码" class="headerlink" title="3、编写代码"></a>3、编写代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start  <span class="comment">/* 全局标号 */</span></span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1、使能所有时钟 ldf如果用大写就全部用大写,如果小写就全部用小写*/</span></span><br><span class="line">    ldr r0, =<span class="number">0X020C4068</span> <span class="comment">//将寄存器CCGR0地址0X020C4068 存放到 寄存器R0 中</span></span><br><span class="line">    ldr r1, =<span class="number">0XFFFFFFFF</span> <span class="comment">//把寄存器x地址0Xffffffff存放到 寄存器r1 中</span></span><br><span class="line">    str r1, [r0]<span class="comment">//把寄存器r1中的值(0XFFFFFFFF) 写入到寄存器r0里面的值作为地址的内存里面</span></span><br><span class="line"></span><br><span class="line">    ldr r0, =<span class="number">0X020C406C</span><span class="comment">/*将寄存器CCGR1地址(0X020C4068) 存放到 寄存器R0 中*/</span></span><br><span class="line">    str r1, [r0]</span><br><span class="line"></span><br><span class="line">    ldr r0, =<span class="number">0X020C4070</span>  <span class="comment">/* CCGR2 */</span></span><br><span class="line">    str r1, [r0]</span><br><span class="line"></span><br><span class="line">    ldr r0, =<span class="number">0X020C4074</span>  <span class="comment">/* CCGR3 */</span></span><br><span class="line">    str r1, [r0]</span><br><span class="line"></span><br><span class="line">    ldr r0, =<span class="number">0X020C4078</span>  <span class="comment">/* CCGR4 */</span></span><br><span class="line">    str r1, [r0]</span><br><span class="line"></span><br><span class="line">    ldr r0, =<span class="number">0X020C407C</span>  <span class="comment">/* CCGR5 */</span></span><br><span class="line">    str r1, [r0]</span><br><span class="line"></span><br><span class="line">    ldr r0, =<span class="number">0X020C4080</span>  <span class="comment">/* CCGR6 */</span></span><br><span class="line">    str r1, [r0]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2、设置GPIO1_IO03复用为GPIO1_IO03 */</span></span><br><span class="line">    ldr r0, =<span class="number">0X020E0068</span><span class="comment">/* 将寄存器SW_MUX_GPIO1_IO03_BASE加载到r0中 */</span></span><br><span class="line">    ldr r1, =<span class="number">0X5</span><span class="comment">/* 设置寄存器SW_MUX_GPIO1_IO03_BASE的MUX_MODE为5 */</span></span><br><span class="line">    str r1,[r0]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3、配置GPIO1_IO03的IO属性</span></span><br><span class="line"><span class="comment">        *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment">        *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ldr r0, =<span class="number">0X020E02F4</span><span class="comment">/*寄存器SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line">    ldr r1, =<span class="number">0X10B0</span></span><br><span class="line">    str r1,[r0]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4、设置GPIO1_IO03为输出 */</span></span><br><span class="line">    ldr r0, =<span class="number">0X0209C004</span><span class="comment">/*寄存器GPIO1_GDIR */</span></span><br><span class="line">    ldr r1, =<span class="number">0X0000008</span></span><br><span class="line">    str r1,[r0]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5、打开LED0</span></span><br><span class="line"><span class="comment">        * 设置GPIO1_IO03输出低电平</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    ldr r0, =<span class="number">0X0209C000</span><span class="comment">/*寄存器GPIO1_DR */</span></span><br><span class="line">   ldr r1, =<span class="number">0</span></span><br><span class="line">   str r1,[r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 描述：loop死循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">loop:</span><br><span class="line">    b loop</span><br><span class="line">.global _start @全局标号</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure><h2 id="4、编译代码"><a href="#4、编译代码" class="headerlink" title="4、编译代码"></a>4、编译代码</h2><p>使用如下三条命令来编译代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -g -c leds.s -o led.o</span><br><span class="line">arm-linux-gnueabihf-ld -Ttext <span class="number">0X87800000</span> led.o -o led.elf</span><br><span class="line">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210702213944379.png" alt="编译、链接、格式转换"></p><p>最终生成了<code>led.o</code> <code>led.elf</code> <code>led.bin</code>三个文件</p><h2 id="5、烧写代码"><a href="#5、烧写代码" class="headerlink" title="5、烧写代码"></a>5、烧写代码</h2><p>STM32中代码烧写到内部FLASH。IMX6ULL支持SD卡、EMMC、NAND、nor、SPI flash等启动。裸机例程选择烧写到SD卡里面。在ubuntu下向SD卡烧写裸机bin文件。烧写不是将bin文件拷贝到SD卡中，而是将bin文件烧写到SD卡绝对地址上。而且对于I.MX而言，不能直接烧写bin文件，比如先在bin文件前面添加头部。完成这个工作，需要使用正点原子提供的imxdownload软件。</p><p><img src="https://img-blog.csdnimg.cn/20210702215521979.png" alt="利用FileZilla Client软件将imxdownload软件发送到工程目录下"></p><p>烧写的三个命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /dev/sd* -l</span><br><span class="line">chmod 777 imxdownload </span><br><span class="line">./imxdownload led.bin /dev/sdb</span><br></pre></td></tr></table></figure><p>Imxdownload使用方法，确定要烧写的SD卡文件，需要使用<code>ls /dev/sd* -l</code>命令来检测SD是哪一个文件，我的是<code>/dev/sdb</code>。</p><p><img src="https://img-blog.csdnimg.cn/20210703143001951.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20210703143110599.png" alt="插拔SD卡可以看到两个的区别"></p><p>给予imxdownload可执行权限：<code>Chmod 777 imxdownload</code></p><p>烧写：<code>./imxdownload led.bin /dev/sdb</code></p><p><img src="https://img-blog.csdnimg.cn/20210703143801135.png" alt="向SD卡烧写完成"></p><p><code>Imxdownlaod</code>会向<code>led.bin</code>添加一个头部，生成新的<code>load.imx</code>文件，这个<code>load.imx</code>文件就是最终烧写到SD卡里面去的。</p><p><img src="https://img-blog.csdnimg.cn/20210703144123428.png" alt=" "></p><p>这里要注意的是如果烧写的速度在几十MB/S左右的话，那么可能意味着烧写失败了。而且是因为SD卡没找到而导致烧写失败，这个问题只能重启 ubuntu解决。</p><p><img src="https://img-blog.csdnimg.cn/20210703144048229.png" alt=" "></p><p>之后就可以从读卡器中把SD拔下来，然后插入到开发板中，将拨码开关拔止SD卡模式，供电之后，蓝色LED亮，红色LED灭，两秒钟之后红色LED亮。</p><p><img src="https://img-blog.csdnimg.cn/20210703151519731.png" alt=" "></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：不知道小伙伴们点亮过多少板子的LED灯，有很多小伙伴留言说讲一下stm32、fpga、liunx他们之间有什么不同，不同点很多，口说无凭，今天就来点亮一下stm32、fpga和liunx板子的led灯，大家大致看一下点灯流程和点灯环境</summary>
      
    
    
    
    <category term="STM32" scheme="http://liuyao-blog.cn/categories/STM32/"/>
    
    <category term="FPGA" scheme="http://liuyao-blog.cn/categories/STM32/FPGA/"/>
    
    <category term="Linux" scheme="http://liuyao-blog.cn/categories/STM32/FPGA/Linux/"/>
    
    
    <category term="STM32" scheme="http://liuyao-blog.cn/tags/STM32/"/>
    
    <category term="FPGA" scheme="http://liuyao-blog.cn/tags/FPGA/"/>
    
    <category term="Linux" scheme="http://liuyao-blog.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一位业余爱好者花两年时间完成的STM32H7掌上电脑(软硬件开源)</title>
    <link href="http://liuyao-blog.cn/posts/1006.html"/>
    <id>http://liuyao-blog.cn/posts/1006.html</id>
    <published>2021-08-23T07:53:50.000Z</published>
    <updated>2021-08-24T05:50:28.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、项目背景"><a href="#1、项目背景" class="headerlink" title="1、项目背景"></a>1、项目背景</h2><p>幼儿时期，还记得一个孩子用泡沫、马达和电池做了一艘电动快艇在河里转着圈圈，泛起的淡淡涟漪让我心潮起伏，驻足河边流连忘返。童年时期，一盒四驱车，让我体验到了毫不起眼的小零件可以组装出这么一台强劲的四驱车。再后来，小霸王学习机风靡时期，经常赖在大孩子家看着别人打游戏自己也感到无比兴奋。初中时期，受风靡一时的文曲星、步步高电子词典中“英雄坛说”、“伏魔记”、“魔塔”带来的深深痴迷，孩提时代就梦想着自己有一天能亲手打造一台硬件软件全自主设计的掌机。</p><p>这个梦伴随着我的成长，让我在大学时代选择了研究电子电路设计、PCB layout、嵌入式编程，直至工作业余时间持续学习实践，终于在2019年7月1日，正式建立工程文件，花费了足足2年业余时间，一点一滴全程设计出名为ALTA-STM32H7掌上电脑，纯粹为了好玩。软件框架使用的安富莱 V7 例程，uCOS-III+emWin+FatFs+ST_USB，只差LWIP 集齐全部。在自己设计的掌机上开发了10个APP，分别是：时钟 APP、音乐 APP、图库 APP、设置 APP、文件 APP、版本 APP、电影 APP、游戏 APP、U 盘 APP、波形 APP。演示视频和图片如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d931f239517f0f6a71ee7ac305f05ea4.png" alt="整体系统展示"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a1bc9d502ca013cf19197833c308d064.png" alt="游戏运行展示"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5ebddec05eb8b13a430166691f0028e8.png" alt="硬件设计展示"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/655506ca793496d7d018b2a38f92521a.png" alt="IPS屏幕展示"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0ac3840a31e26c740bc40050408b15d0.png" alt="金手指核心板正面展示"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9934f32bad79502ed5d4a88bf9dfb2c5.png" alt="金手指核心板背面展示"></p><h2 id="2、硬件设计"><a href="#2、硬件设计" class="headerlink" title="2、硬件设计"></a>2、硬件设计</h2><p>硬件构架采用核心板+底板+屏幕，使用 Alitum 软件绘制原理图，PADS 绘制 PCB 板。核心板为金手指 6 层设计，底板为 2 层设计，屏幕为 2 层设计。具体硬件明细如下。</p><h2 id="2-1、核心板配置"><a href="#2-1、核心板配置" class="headerlink" title="2-1、核心板配置"></a>2-1、核心板配置</h2><ul><li>CPU ： STM32H743XIH6（M7 核心、480MHz 主频、2MB Flash，1MB RAM）</li><li>SDRAM ： IS42S32800G-6BLI（32 位，32MB）</li><li>QSPI Flash ： W25Q256JVEIQ（4 线总线宽度，容量 32MB，支持 XIP，即可运行程序）</li><li>SPI Flash ： W25Q64JVZEIQ（容量 8MB）</li><li>NAND Flash ： MT29F4G08ABADAWP:IT（8 位总线宽度，容量 512MB）</li><li>SD 卡座：Micro SD Card</li><li>显示器接口：RGB 24bit、I2C 触摸、背光可调</li><li>Typec-C 型 USB 口：1 个 USB Device 全速</li><li>LED 灯 ： 2 个指示灯</li><li>串行接口 ： 1 个</li><li>SWD 下载接口 ： 1 个</li><li>按键 ： 1 个复位键，1 个唤醒按键</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/f2ec6b3fe11a9a10fdf2934f92ed1199.png" alt="核心板正面PCB图"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a3980cdc4feacc1f1be77429c16e9ade.png" alt="核心板背面PCB图"></p><h2 id="2-2、底板配置"><a href="#2-2、底板配置" class="headerlink" title="2-2、底板配置"></a>2-2、底板配置</h2><ul><li>二合一锂电池充电升压 IC ： TP5400/TP5410 （充电：4.2V/1A，输出 5V/1A）</li><li>二合一锂电池保护 IC ： DW06D</li><li>电量监控 IC ： STC3100</li><li>线性 LDO IC ： AMS1117-3.3</li><li>电压参考 IC ： LM285D-2.5</li><li>光照强度 IC ： BH1730FVC</li><li>EEPROM ： AT24C02C-STUM-T</li><li>实时时钟 IC ： DS3231M</li><li>以太网 IC ： LAN8720A</li><li>音频 IC ： WM8978CGEFL（24 位 ADC 与 DAC）</li><li>Typec-C 型 USB 口 ： 1 个 USB Device 全速，1 个串行接口（CH340G USB 转串口芯片）</li><li>A 型 USB 口 ： 1 个 USB HOST 全速</li><li>电池座子 ： 1 个双 18650 锂电池座子，1 个 CR1220 纽扣电池底座</li><li>无线模块 ： NRF24L01（2.4GHz、SPI 接口驱动）</li><li>温度模块 ： DS18B20</li><li>湿度模块 ： DHT11</li><li>耳机插座 ： 1 个音源输入，1 个音源输出</li><li>按键 ： 1 个开机键，1 个确认键，1 个取消键，1 个 ISP 下载键，1 个复位键</li><li>LED 灯 ： 1 个电源灯，3 个指示灯</li><li>蜂鸣器 ： 1 个（9055 有源蜂鸣器 3V 9*5.5MM）</li><li>麦克风 ： 1 个（6 * 2.2mm咪头 6022 尺寸）</li><li>SWD 下载接口 ： 1 个</li><li>扬声器 ： 1 个（8 欧姆）</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/f5c6a5b21cd9a9f8a4d46602c4f5ad79.png" alt="底板正面PCB图"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9c69d2347d2eaf30454d81bc98e0cd36.png" alt="底板背面PCB图"></p><h2 id="2-3、屏幕配置"><a href="#2-3、屏幕配置" class="headerlink" title="2-3、屏幕配置"></a>2-3、屏幕配置</h2><ul><li>RGB 电容触摸屏（并行 24 位 RGB 接口、分辨率 800*480、全视角 IPS、5 英寸、GT911 电容触摸）</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ab56a6de4295c908339ed0588b0e1420.png" alt="RGB屏幕正面PCB图"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4447deb0a2bdef3a1538ad8929f190d9.png" alt="RGB屏幕背面PCB图"></p><h2 id="3、软件设计"><a href="#3、软件设计" class="headerlink" title="3、软件设计"></a>3、软件设计</h2><h2 id="3-1、软件版本"><a href="#3-1、软件版本" class="headerlink" title="3-1、软件版本"></a>3-1、软件版本</h2><p>软件框架为 uCOS-III+emWin+FatFs+ST_USB，还差网络没有加上，具体软件版本见如下列表</p><ul><li>ST_HAL 库 版本：V1.10.0</li><li>BSP 驱动包 版本：V1.2</li><li>uCOS-III 版本：V3.08.00</li><li>uC/CPU 版本: V1.32.00</li><li>uC/LIB 版本: V1.39.00</li><li>emWin 版本：V6.10</li><li>FatFS 版本：V0.14</li><li>ST_USBD 版本：V2.7.1</li><li>ST_USBH 版本：V3.3.4</li></ul><h2 id="3-2、掌机主界面及应用-APP-介绍"><a href="#3-2、掌机主界面及应用-APP-介绍" class="headerlink" title="3-2、掌机主界面及应用 APP 介绍"></a>3-2、掌机主界面及应用 APP 介绍</h2><p>基于ALTA-STM32H7 掌机开发的 10 个 APP 分别是：时钟 APP、音乐 APP、图库 APP、设置 APP、文件 APP、版本 APP、电影 APP、游戏 APP、U 盘 APP、波形 APP。</p><ul><li>主机面左侧透明区域为锂电池监测信息、emWin 的剩余内存（emWin 总共分配了 24MB）、和传感器（光照强度、温度、湿度）数据显示</li><li>主界面右侧区域为 APP 布局界面，采用 ICONVIEW 控件，一共显示了 12 个 APP</li><li>主界面下册区域为任务栏，有关机 Win 键和时间日期的同步显示</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/8fba446303485ca13fb395eef3b6ad56.png" alt="桌面界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/88415ecd738a98819258e5ef303cc9f6.png" alt="关机界面"></p><h3 id="3-2-1、时钟-APP"><a href="#3-2-1、时钟-APP" class="headerlink" title="3-2-1、时钟 APP"></a>3-2-1、时钟 APP</h3><ul><li>时钟主界面左侧显示表盘，模拟时、分、秒指针，右侧显示时间、日期和时钟芯片温度</li><li>时钟子界面采用 LISTWHEEL 控件，实现调整年、月时，自动调整日的最大值。如：将日期 2020-02-29 调整年为 2021，则天自动调整为 28</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/181ec3f64ee85f0e4863e11e89f29929.png" alt="时钟主界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a4ea56c18b4b4fa87d30c9cd93d78373.png" alt="时钟子界面"></p><h3 id="3-2-2、音乐-APP"><a href="#3-2-2、音乐-APP" class="headerlink" title="3-2-2、音乐 APP"></a>3-2-2、音乐 APP</h3><ul><li>音乐主界面碟片是打开列表的按钮。主界面有音量、进度调节、耳机与外放切换，上一曲、下一曲、播放、暂停功能</li><li>音乐子界面采用 LISTVIEW 控件，显示音乐列表</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/cded8a01b3c199dfce2296cf39c59886.png" alt="音乐主界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8fbc87e38eae9ab408ae8e6bae865964.png" alt="音乐子界面"></p><h3 id="3-2-3、图库-APP"><a href="#3-2-3、图库-APP" class="headerlink" title="3-2-3、图库 APP"></a>3-2-3、图库 APP</h3><ul><li>图库主界面采用 LISTVIEW 控件，显示图片列表</li><li>选择图片后全屏显示。点击图片左侧，向上切换图片。点击图片右侧，向下切换图片。点击图片中间，关闭图片</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/3ee5bf028c2923ff9a045b9fda7b7fe5.png" alt="图库主界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/374ff2c9c8430cd4ed3e59b8b8c80858.png" alt="图库子界面"></p><h3 id="3-2-4、设置-APP"><a href="#3-2-4、设置-APP" class="headerlink" title="3-2-4、设置 APP"></a>3-2-4、设置 APP</h3><ul><li>调节系统背光和系统音量，自动调节背光功能待开发</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/dcb5b4e2165a1daf41895da9c643c07f.png" alt="设置主界面"></p><h3 id="3-2-5、文件-APP"><a href="#3-2-5、文件-APP" class="headerlink" title="3-2-5、文件 APP"></a>3-2-5、文件 APP</h3><ul><li>文件主界面显示内部储存设备（3 个内部储存设备并未开发）和移动储存设备（SD 卡和 U 盘容量显示）</li><li>文件子界面采用 CHOOSEFILE 控件，仅用于浏览 SD 卡和 U 盘中文件内容，但不能打开文件</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/7110081ea495976fc0d987fa9b40d194.png" alt="文件主界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/05fd86623cf190e2e1b347e1604a9faa.png" alt="文件子界面"></p><h3 id="3-2-6、版本-APP"><a href="#3-2-6、版本-APP" class="headerlink" title="3-2-6、版本 APP"></a>3-2-6、版本 APP</h3><ul><li>显示硬件和软件设计版本，手机扫描二维码会进入个人网站：<code>www.mazirong.com</code></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/2e665311aaa5071ee611e30e2b194e8d.png" alt="版本主界面"></p><h3 id="3-2-7、电影-APP"><a href="#3-2-7、电影-APP" class="headerlink" title="3-2-7、电影 APP"></a>3-2-7、电影 APP</h3><ul><li>电影 APP 为双图层（图层 1 底层，图层 2 上层。程序默认运行在图层 1）设计，有关操作的按钮和进度条均在图层 2，电影播放在图层 1</li><li>注意使用格式工厂软件转化视频时，视频分辨率为 800*480，且每秒帧数不推荐超过 30 帧，防止帧率太高无法播放</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ab3fa446cd12b0c1d4b93ee7221f2b02.png" alt="电影界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4a89a9de1666ab05a48b0f0c7ab0ff7f.png" alt="电影界面"></p><h3 id="3-2-8、游戏-APP"><a href="#3-2-8、游戏-APP" class="headerlink" title="3-2-8、游戏 APP"></a>3-2-8、游戏 APP</h3><ul><li>移植自网友 ye781205 的 nes 模拟器，实现外界 USB 游戏手柄畅玩 nes 类游戏</li><li>游戏主界面采用 LISTVIEW 控件，显示游戏列表。选择进入游戏后，运行 nes 模拟器</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/646d3c9d4b9388eccee6da83be71a9ae.png" alt="游戏主界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e59ad847460948b07c2a41e9ce55b1a.png" alt="游戏子界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/312133c31fe01997901c894138d7bfba.png" alt="游戏子界面"></p><h3 id="3-2-9、U-盘-APP"><a href="#3-2-9、U-盘-APP" class="headerlink" title="3-2-9、U 盘 APP"></a>3-2-9、U 盘 APP</h3><ul><li>使用 Type-C 的 USB 数据线连接板子插入电脑，点击 USB Open 按钮，过几秒中电脑会显示出 SD 卡磁盘</li><li>在与电脑连接状态下，点击 USB Close，立刻从电脑移除 SD 卡磁盘</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/f2439ebe259e077efe099b52ec53a4b5.png" alt="U 盘主界面"></p><h3 id="3-2-10、波形-APP"><a href="#3-2-10、波形-APP" class="headerlink" title="3-2-10、波形 APP"></a>3-2-10、波形 APP</h3><ul><li>波形主界面模拟 2 个波形，波形幅度设置为 120 至 220</li><li>波形子界面采用三原色配置背景、栅格、波形等颜色</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/da2b620fdd063e3eaf1a0dfcf9dd56c2.png" alt="波形主界面"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3f68674702e37a5a9e5a7635df3cd463.png" alt="波形子界面"></p><p>自此，ALTA-STM32H7 掌机项目软硬件设计介绍完毕，后续可能全部开源，欢迎各位电子爱好者，极客朋友留言交流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、项目背景&quot;&gt;&lt;a href=&quot;#1、项目背景&quot; class=&quot;headerlink&quot; title=&quot;1、项目背景&quot;&gt;&lt;/a&gt;1、项目背景&lt;/h2&gt;&lt;p&gt;幼儿时期，还记得一个孩子用泡沫、马达和电池做了一艘电动快艇在河里转着圈圈，泛起的淡淡涟漪让我心潮起伏，驻足河</summary>
      
    
    
    
    <category term="STM32" scheme="http://liuyao-blog.cn/categories/STM32/"/>
    
    
    <category term="STM32" scheme="http://liuyao-blog.cn/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>软件神器TortoiseGit，图形化方式管理单片机程序版本</title>
    <link href="http://liuyao-blog.cn/posts/1004.html"/>
    <id>http://liuyao-blog.cn/posts/1004.html</id>
    <published>2021-08-23T07:13:49.000Z</published>
    <updated>2021-08-24T05:51:57.445Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>：大家肯定都写过毕业论文，写毕业论文的时候，每次修改之前，都会先把当前最新的版本复制一份，然后再重新命名一个标题，但是，之前的旧版本又不会删掉，为了保险起见，感觉万一新的文档没改好还能有个旧的版本可以用。</p><p>于是，就有了下面的一幕</p><p><img src="https://img-blog.csdnimg.cn/2021070311013953.png" alt=" "></p><p>大家别笑，这都是真实发生的案例，更有甚者，自己笔记本拷贝毕业论文到U盘，<strong>在其它电脑修改了，又忘记更新回自己电脑</strong>，或者，时间长了，想找到之前文档中的一些文字，<strong>但是又忘记在那个版本来。</strong></p><p>是不是非常苦恼，你可能觉得，那我找回之前的版本一个个查看不就可以了，又没删，但是你这才几个文件，如果文件数量翻几倍呢？</p><p><strong>那么，有没有什么软件可以帮助我们对文件进行版本控制呢</strong>？今天，晓宇姐姐教大家用<code>Git</code>来进行版本控制。</p><p>听到Git，一些单片机或者是软件开发的初学者又打算停止看下去了，好麻烦啊，又得记一堆命令，每次改完我也懒得命令提交，我还是通过日期来记录好了，于是又出现下面一幕：</p><p><img src="https://img-blog.csdnimg.cn/20210703104558319.png" alt=" "></p><p>项目完成初期，还大致记得每个版本改了什么，1个月后，需要某个旧版本的信息，或者新的版本出了什么问题，<strong>需要追溯查找改动的代码部分</strong>，这时候，麻烦就来了，工程师喃喃自语道 “<strong>我好像记得改了这个地方，但是不知道是不是只有这个地方改动来”，然后，很苦逼的一个文件一个文件的去对比</strong>。</p><p>看到上面的这一幕，我们肯定不想重蹈上面工程师的覆辙，但是即使用文件记得再详细，当在不同电脑，或者是不同工程师开发同一个项目的时候，几乎不可能不出错的记录，<strong>而且这样记录，很累</strong>。</p><p>上面说的一大堆，所谓欲扬先抑，就是为了引出我们今天的主角，一个软件版本控制神器<strong>TortoiseGit</strong>。</p><p>TortoiseGit，简称tgit，中文名海龟Git，是一个GIT版本控制系统的客户端。</p><p>我们需要先下载几个软件，并依次安装好：</p><p>1、Git-2.28.0-64-bit，大家根据自己的系统下载<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>2、TortoiseGit<a href="https://tortoisegit.org/download/">https://tortoisegit.org/download/</a></p><p>3、TortoiseGit  Language Packs，汉化包，下载链接同上。</p><p><img src="https://img-blog.csdnimg.cn/20210703091516103.png" alt="TortoiseGit安装包"></p><p><img src="https://img-blog.csdnimg.cn/20210703091630481.png" alt="汉化包"></p><p>我们在E盘项目文件下创建一个文件夹，用来存储以太网网关项目的资料，并右键执行如下操作，在此文件夹下面创建一个版本库：</p><p><img src="https://img-blog.csdnimg.cn/20210703105011534.png" alt="创建版本库"></p><p>可以看到，在文件夹下多了一个<code>.git</code>的隐藏文件夹，千万不要删掉，这个就是我们的版本记录文件。</p><p>进行正式操作之前，我们先简单配置一下软件：</p><p><img src="https://img-blog.csdnimg.cn/20210703092742719.png" alt="设置"></p><p><img src="https://img-blog.csdnimg.cn/20210703092931571.png" alt="修改软件语言和git路径"></p><p><img src="https://img-blog.csdnimg.cn/20210703093052366.png" alt="编辑全局"></p><p>最后一幅图，配置用户信息，做为用户操作git的个人标识，我们填写<strong>个人名称</strong>和<strong>邮箱</strong>，然后编辑一下全局变量，加入以下配置，用于记住密码。之后保存退出即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[credential]</span><br><span class="line">  helper = store</span><br></pre></td></tr></table></figure><p>我们把我们第一版本的工程文件放入software文件夹下，然后打开工程，这就是我们的V1.0.0版本的原始程序了。</p><p><img src="https://img-blog.csdnimg.cn/20210703094010224.png" alt=" "></p><p>V1.0.0版本的程序写好之后，我们需要先提交一次，如下操作：</p><p><img src="https://img-blog.csdnimg.cn/20210703094048495.png" alt="准备提交"></p><p>然后会弹出一个对话框，注意，这个是重点：</p><p><img src="https://img-blog.csdnimg.cn/20210703094225359.png" alt=" "></p><p>第一个红框中，需要填写版本日志信息，需要说明这个版本所更新的内容；第二个红框中，为提交者的的名字以及提交的日期，这个主要在多人协同中比较有用；第三个红框勾选全部，然后会把本次更新所涉及到的文件全部选中，最后选择提交。</p><p>看到下图红框中的成功，表示本次推送成功，这里，仅仅是把更新推送到本地Git仓库，文件都还在本地。</p><p><img src="https://img-blog.csdnimg.cn/20210703094335331.png" alt="推送本地库成功"></p><p>我们的代码版本，不仅可以存在本地仓库存储，还可以推送到云端服务器进行保存，我们可以搭建本地的Git服务器，也可以使用现成的Git服务器，这里推荐其中一个平台码云。</p><p>对的，你没听错，是<strong>码云</strong>，网址：<a href="https://gitee.com/">https://gitee.com/</a>，大家各自注册号账号。</p><p>然后，按照下图建立一个私有仓库</p><p><img src="https://img-blog.csdnimg.cn/20210703094443506.png" alt="新建仓库"></p><p><img src="https://img-blog.csdnimg.cn/20210703094706574.png" alt="填写仓库信息"></p><p><img src="https://img-blog.csdnimg.cn/20210703095103213.png" alt="复制仓库地址"></p><p>点击管理，把我们刚刚复制的那个链接放进URL框中，点击保存。这个链接是我们项目的远端地址，也是我们将本</p><p><img src="https://img-blog.csdnimg.cn/20210703094838610.png" alt="向远端推送"></p><p><img src="https://img-blog.csdnimg.cn/2021070309503082.png" alt="设置远端推送信息"></p><p>确认文件推送的地址，然后确定推送。</p><p><img src="https://img-blog.csdnimg.cn/20210703102832113.png" alt="推送成功"></p><p>如果推送失败，需要<strong>先拉取一下服务器文件更新一下本地仓库</strong>，然后再推送即可。</p><p>推送成功之后，我们看看网页端有什么变化。</p><p><img src="https://img-blog.csdnimg.cn/20210703103024923.png" alt=" "></p><p>主页动态框这里，马上就更新了，提示，某某某在什么时间段推送了什么文件到哪个分支，在多人服务同一个项目的时候特别有用。</p><p>我们再看看项目页面，可以看到，我们的整个工程文件都更新到服务器了。</p><p><img src="https://img-blog.csdnimg.cn/20210703102910468.png" alt="更新完成"></p><p>过了几天，我们更新了V1.1.0版本，在主函数中增加了一句话，部分改动如下：</p><p><img src="https://img-blog.csdnimg.cn/20210703103215339.png" alt=" "></p><p>我们保存编译之后，重新提交，方法还是按照上面的，提交之前，我们看到文件夹的图标由之前绿色的对号变成了红色的感叹号，绿色代表文件目前都是最新的，红色代表里面又改动过了，还没提交。</p><p><img src="https://img-blog.csdnimg.cn/2021070310345469.png" alt=" "></p><p>同样的开始推送</p><p><img src="https://img-blog.csdnimg.cn/2021070310352429.png" alt=" "></p><p>我们在可以看到本次提交的变更列表中，主要改动的就是添加了一句话。</p><p><img src="https://img-blog.csdnimg.cn/2021070310373047.png" alt=" "></p><p><strong>黄色背景部分直接就显示出了新旧两个版本之间改动过的地方，这一功能是不是特有用</strong>，当我们想找回以前版本到底改动了哪些的时候，直接在对话框中选中相应的版本，<strong>然后在变更列表中我们就可以很清晰的看出被改动过的每一行。</strong></p><p>然后我们像之前一样点击提交，提交之后，可以再网页动态看到本次提交的信息，然后在项目统计这里，我们可以看到完整的项目提交历史。</p><p><img src="https://img-blog.csdnimg.cn/20210703103916645.png" alt=" "></p><p>在本地文件夹，我们也可以查看版本记录，方法如下：</p><p><img src="https://img-blog.csdnimg.cn/20210703104048943.png" alt="查看日志"></p><p>在这个界面，我们可以非常清晰的看到各个版本之间的变更信息，提交的作者以及日期，对于我们掌控整个项目的生命周期，能起到非常重要的作用。</p><p><img src="https://img-blog.csdnimg.cn/20210703104010644.png" alt=" "></p><p>我们想导出哪个历史版本，直接在对应版本右键导出即可。</p><p>啰嗦了一大堆，我们上面说的，<strong>说白了就是一个软件，这个软件可以帮助我们以可视化的方式管理我们的程序版本，方便我们追溯回顾历史更改，同时可以提交到服务器，便于备份文件</strong>，同时，也方便我们在不同的地点，环境修改代码，改完之后提交到服务器，这样，这服务器永远保留最新的版本，不同的终端也可以看到修改的问题点，大大的方便了我们的项目管理。</p><p>本次先带大家简单入门，大家也可以自己摸索，<strong>TortoiseGit的功能非常强大</strong>，我们这里只是介绍了其中一部分，剩下的下次再跟大家唠嗑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：大家肯定都写过毕业论文，写毕业论文的时候，每次修改之前，都会先把当前最新的版本复制一份，然后再重新命名一个标题，但是，之前的旧版本又不会删掉，为了保险起见，感觉万一新的文档没改好还能有个旧的版本可以用。&lt;/p&gt;
&lt;p&gt;于是，就有了下面</summary>
      
    
    
    
    <category term="TortoiseGit" scheme="http://liuyao-blog.cn/categories/TortoiseGit/"/>
    
    
    <category term="TortoiseGit" scheme="http://liuyao-blog.cn/tags/TortoiseGit/"/>
    
  </entry>
  
  <entry>
    <title>公众号|博客原创图文汇总——必看</title>
    <link href="http://liuyao-blog.cn/posts/1001.html"/>
    <id>http://liuyao-blog.cn/posts/1001.html</id>
    <published>2021-08-22T07:48:49.000Z</published>
    <updated>2021-08-24T05:51:48.956Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210715171443971.png" alt=" "></p><p><strong>摘要</strong>：公众号到现在已经陆续更新100多篇原创图文了。今天汇总一下原创图文，一来方便自己查看，有些知识一旦很长时间不用，会很容易忘掉。二是希望能帮助到更多的小伙伴，祝大家学有所成，学的开心。</p><h2 id="手把手系列"><a href="#手把手系列" class="headerlink" title="手把手系列"></a>手把手系列</h2><p><a href="https://mp.weixin.qq.com/s/do4cE-vOyQXwiDcE0_JNZA">干货|教你使用Doxygen制作漂亮的程序文档</a><br><a href="https://mp.weixin.qq.com/s/1nqb-Q5bGXq6e5SVp5VgUw">干货|手把手教你做一辆迷你平衡摩托车</a><br><a href="https://mp.weixin.qq.com/s/xRaHkhnD2pON1Ua0OdPMmg">干货|手把手教你制作炫酷的PCB板3D爆炸图</a><br><a href="https://mp.weixin.qq.com/s/aIidfGLhwvdCZ9SUPrM80g">干货|手把手教你VSCode搭建STM32开发环境</a><br><a href="https://mp.weixin.qq.com/s/Yw5aO-8TLEfr5CAPQ-4JMg">干货|手把手带你搞懂Modbus通信协议</a><br><a href="https://mp.weixin.qq.com/s/LXfpmbehf7TdqrwphA8PbQ">干货|手把手教你写一个串口调试助手</a><br><a href="https://mp.weixin.qq.com/s/MkFj68VAg7tU9rIBegnhOg">干货|手把手教你制作一个示波器</a><br><a href="https://mp.weixin.qq.com/s/HzJDZezenbVkRtpaJ63RjA">干货|手把手教你自制轮式机器人</a><br><a href="https://mp.weixin.qq.com/s/V2wxZL0p2RSYXjxJySi_Eg">干货|手把手教你自制六足仿生机器人</a><br><a href="https://mp.weixin.qq.com/s/lbHnBqIBAYiR_QXjcc-Ndw">工具|手把手教你在VSCode中使用Git</a><br><a href="https://mp.weixin.qq.com/s/biZDX0HWMSC8nxiJOLAKzA">干货|手把手教你写单片机的结构体</a><br><a href="https://mp.weixin.qq.com/s/sqJaL6fVJUZevMDtQDh2Hw">干货|手把手教你写单片机的指针</a><br><a href="https://mp.weixin.qq.com/s/4Mz5ekc7FzfX2soiOtE6wA">干货|手把手教你写一个安卓app</a><br><a href="https://mp.weixin.qq.com/s/EONf_Kz3NSW-s_WwaVc4Sw">干货|手把手教你在显示设备上制作一个菜单</a><br><a href="https://mp.weixin.qq.com/s/ggA2x_prpV9EWO_uIyNUHA">干货|手把手教你用蓝牙模块</a><br><a href="https://mp.weixin.qq.com/s/QYIvSe40W73eD-gt0_FizQ">开源|手把手教你造一个火星车</a><br><a href="https://mp.weixin.qq.com/s/nfJfePnmqQuNNPzhbYtNTw">开源|Qt for Android应用开发</a><br><a href="https://mp.weixin.qq.com/s/q52zDRKIKsnRuYTjmUC4Wg">开源|基于QT的安卓手机蓝牙APP开发</a><br><a href="https://mp.weixin.qq.com/s/zRXvEOJZHb5uoodAD7wXcw">干货|果果教你利用Inno setup打包QT程序</a><br><a href="https://mp.weixin.qq.com/s/rLw40Ps0W_YPFZpWbsJBQw">干货|基于QT5的串口&amp;网络调试助手</a><br><a href="https://mp.weixin.qq.com/s/4U8ccGAAZBCi52aIwCOAbw">开源|零基础一周完成平衡小车项目</a><br><a href="https://mp.weixin.qq.com/s/9wn1TtTljKOmqOjRJB2u0A">硬核|稚晖君教你制作全球最迷你的自平衡机器人</a><br><a href="https://mp.weixin.qq.com/s/WVDVczc5ERQGbcZ-5oKOeQ">干货小师妹教你用QT新建一个工程</a><br><a href="https://mp.weixin.qq.com/s/DABF2LnFDkgBpUpAY3wMYw">干货|使用QT绘图控件QCustomPlot绘制波形图</a><br><a href="https://mp.weixin.qq.com/s/QpkVol1RSctZYNOX1azynQ">干货|手把手教你用Labview写一个串口上位机</a><br><a href="https://mp.weixin.qq.com/s/ZKTfYzBgFkyEfbDQFUBF8g">干货|手把手教你使用Gitee+PicGO搭建高效图床</a></p><h2 id="软件工具推荐"><a href="#软件工具推荐" class="headerlink" title="软件工具推荐"></a>软件工具推荐</h2><p><a href="https://mp.weixin.qq.com/s/0PLx5t3ioedZ7MlmiYiFbA">小试牛刀|H7-TOOL的RTT功能很棒</a><br><a href="https://mp.weixin.qq.com/s/VSsX9OyRI8NqS7h2-ySQyg">零基础入门Git&amp;Github</a><br><a href="https://mp.weixin.qq.com/s/CovRlc-HryPa8QRPvuwuLg">在VScode搭建C/C++开发环境</a><br><a href="https://mp.weixin.qq.com/s/vOHjoIpjlSTQxtMWx4dUGw">立创EDA元件封装导入AD软件教程</a><br><a href="https://mp.weixin.qq.com/s/tT1fV5mvzSYhRvJXDQl5UQ">如何下载别人公众号的图片和视频</a><br><a href="https://mp.weixin.qq.com/s/XdVSGvNg7FP-Q332ooPDig">最专业的嵌入式开发调试工具</a><br><a href="https://mp.weixin.qq.com/s/JDJMOAj22KAQ9Dd-2FdVGA">用CubeMX + HAL库开发它不香吗？</a><br><a href="https://mp.weixin.qq.com/s/qG5rCbPd660iTllvT3hmRw">干货|使用Notepad++和MinGW编译C代码</a><br><a href="https://mp.weixin.qq.com/s/Mq-n41FTa-YhEkD18jBtyw">电子工程师必备的调试神器—H7-TOOL</a><br><a href="https://mp.weixin.qq.com/s/-Or54iJXkWlerzoYnHW6-A">推荐五款你从未见过的嵌入式电子电路仿真APP</a><br><a href="https://mp.weixin.qq.com/s/kwqV5ONuwBR9ceXntjo4vg">Keil中使用AStyle插件对代码格式美化处理</a><br><a href="https://mp.weixin.qq.com/s/DQl0yVRuuKUw6VChUK24ew">VOFA+|一款最强大的插件驱动高自由度的上位机</a></p><h2 id="STM32单片机"><a href="#STM32单片机" class="headerlink" title="STM32单片机"></a>STM32单片机</h2><p><a href="https://mp.weixin.qq.com/s/zKohUbbDQ3HOWdk3Kto9Ww">傅里叶变换其实并不难</a><br><a href="https://mp.weixin.qq.com/s/B7WRW0RGDKqFo38UpzTXgA">史上最全的H桥电机驱动电路详解</a><br><a href="https://mp.weixin.qq.com/s/uYYE4YfK8_93FMZ2wPmeNw">华为太空人智能表盘代码仅需100行？</a><br><a href="https://mp.weixin.qq.com/s/Almvmd_kuqA0wc9qaC5HFw">有屏幕的地方就有badapple(附教程)</a><br><a href="https://mp.weixin.qq.com/s/VfyF_PsdewuJnsQVQQE2fQ">STM32第一章-你懂内存和寄存器吗？</a><br><a href="https://mp.weixin.qq.com/s/qhhcbYIlMFx_YZhWW2RwWQ">STM32第二章-启动过程详解</a><br><a href="https://mp.weixin.qq.com/s/393O5xU4vGMjVzmS1_OfKg">STM32第三章-系统时钟配置</a><br><a href="https://mp.weixin.qq.com/s/WsClu0uicr8JGwH5l5_LUg">STM32第四章-外部中断管理</a><br><a href="https://mp.weixin.qq.com/s/f5amjEIYDSqsG_sS1_ai-w">STM32第五章-串口通讯详解</a><br><a href="https://mp.weixin.qq.com/s/6rHEp-dYb3iM_aUHjRZvrA">STM32第六章-TIM定时器详解</a><br><a href="https://mp.weixin.qq.com/s/HNvA4q36EInVge7frj4A7w">STM32第七章-脉冲宽度调制</a><br><a href="https://mp.weixin.qq.com/s/_TYbkn_u8xqfesrAfTmvmg">STM32第八章-TIM输入捕获</a><br><a href="https://mp.weixin.qq.com/s/sh3njJcBZPvEDUzJJ29pag">STM32第九章-IIC通讯应用</a><br><a href="https://mp.weixin.qq.com/s/FWj_bc6ENfuOWqSvR5fUKQ">STM32第十章-SPI通讯应用</a><br><a href="https://mp.weixin.qq.com/s/24MCY4mwDxtMQmWOzzaL9A">利用C语言读取BMP文件</a><br><a href="https://mp.weixin.qq.com/s/xow0SieFNMnHL4ZREkr4jw">bmp图片灰度化与二值化</a><br><a href="https://mp.weixin.qq.com/s/SC5pbetIb2y9FU0zXScLlw">#Pragma Pack(n)字节对齐</a><br><a href="https://mp.weixin.qq.com/s/35V2wxYyQ0eO1O2Wvnepiw">一行代码！生成自己QQ、微信的动态二维码</a><br><a href="https://mp.weixin.qq.com/s/oqgG58wyQ2VmmS4mzAg2Lg">硬件分享|飞卡硬件PCB大放送！</a><br><a href="https://mp.weixin.qq.com/s/fp_TRszhgyO5tK0rGvoi0Q">一文搞懂0.1UF和10UF电容并联使用技巧</a><br><a href="https://mp.weixin.qq.com/s/tsOH2jHye19-MLTpfnJulQ">FPGA的Veilog HDL语法、框架总结</a><br><a href="https://mp.weixin.qq.com/s/Zqmlt0UkWkHG9fzRrBOHhw">我的第一个FPGA开发项目——二选一多路器</a><br><a href="https://mp.weixin.qq.com/s/fcXFYBMwTTRX59f25wMHxw">史上最全的LED点灯程序，你都掌握了吗？</a><br><a href="https://mp.weixin.qq.com/s/AqVEzglSNvMZz9LHIh_2sw">STM32驱动舵机原理和实现</a><br><a href="https://mp.weixin.qq.com/s/GpskFjyCs8zrjc5APGAmrg">基于STM32的MLX90614人体红外测温枪</a><br><a href="https://mp.weixin.qq.com/s/Z_Dlx_OnNw2s0lTIFUm5_A">项目分享|基于STM32超声波避障小车</a><br><a href="https://mp.weixin.qq.com/s/W35U44qZOqB8VzPJ-AEZWA">低功耗待机模式+RTC闹钟中断唤醒</a><br><a href="https://mp.weixin.qq.com/s/2OwwH9xf2L3cBafbu4FVxQ">你必须知道的单片机存储器的那些事！</a><br><a href="https://mp.weixin.qq.com/s/JNEOnWuKzwB-1MXB3yGO1g">开源基于STM32的PS2遥控小车</a><br><a href="https://mp.weixin.qq.com/s/nv0kaArHlZO-U4d8t0qOsg">给你的代码升个级？—IAP</a><br><a href="https://mp.weixin.qq.com/s/vJtz7RWZr4pzo7EW479_fA">在华为鸿蒙OS上我的第一个“hello world”</a><br><a href="https://mp.weixin.qq.com/s/yewnqWxLfxH_4LfwnvrRag">一位业余爱好者花两年时间完成的STM32H7掌上电脑</a><br><a href="https://mp.weixin.qq.com/s/0is4XMRRrewDKNxy2Jr_VQ">一文带你搞懂内存中数据的读写方式</a><br><a href="https://mp.weixin.qq.com/s/DRSVS1xFlpCpKyrSvlZV-w">RTOS真的很难吗？一起来移植看看</a></p><h2 id="程序人生"><a href="#程序人生" class="headerlink" title="程序人生"></a>程序人生</h2><p><a href="https://mp.weixin.qq.com/s/lKlnJv8HQMWNk_QpDOAI1Q">励志|我的19岁</a><br><a href="https://mp.weixin.qq.com/s/kJNBgymFOrZqYUb_6wxKvA">励志|不忘初心，方得始终</a><br><a href="https://mp.weixin.qq.com/s/5ml3iAo5CCRWcfqC5jsGqg">励志|一个普通人的大学四年生活</a><br><a href="https://mp.weixin.qq.com/s/mEP0UxGwtuZp0GAPhiNTvw">良药|如何做一名合格的研究生？</a><br><a href="https://mp.weixin.qq.com/s/fok0nopp0ChDGQEcaLQ3Vg">福利|一万粉啦！3000元大礼包相送！</a><br><a href="https://mp.weixin.qq.com/s/10WYFwxyyqxOADgMlxNL_g">好快啊，我的研究生生涯结束了！</a><br><a href="https://mp.weixin.qq.com/s/CZV0V9WhTQWTgPbXYp4o0w">小师妹和小师弟一起交流学习！</a><br><a href="https://mp.weixin.qq.com/s/hbSzLp7JUui9I7VGwoCWoQ">华为天才少年——稚晖君！</a><br><a href="https://mp.weixin.qq.com/s/bHBSEVuFlx4vi6-zT7-Kqg">分享是程序员的必备素质</a><br><a href="https://mp.weixin.qq.com/s/5Rga4xMAExqIfAm7WBEbxA">果果带你学模电，一战成硕！</a><br><a href="https://mp.weixin.qq.com/s/XgzMFHeFZUxOJGqe9MFM6A">程序是如何运行的呢？</a><br><a href="https://mp.weixin.qq.com/s/PVFqHcSBw7Qq7wy_RWBfAw">佛祖保佑 永不宕机 永无BUG</a><br><a href="https://mp.weixin.qq.com/s/NHcIQWtW4nVpz8GAHonLRg">我学电子的，能做我的女朋友吗？</a><br><a href="https://mp.weixin.qq.com/s/eEHkP1pr1GcqRzIeMdVNFw">哪个男孩不想拥有一台示波器呢？开箱DS100</a></p><h2 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h2><p><a href="https://mp.weixin.qq.com/s/jwhYvkvvi6rgIpqAE8AWsQ">烂大街的ESP8266该怎么玩！</a><br><a href="https://mp.weixin.qq.com/s/at1ufe7uQ7iMNvJs_Uwbgw">物联网—IOT你真的懂吗？</a><br><a href="https://mp.weixin.qq.com/s/mLVIR4CrsH9-x-MEkl_hAA">物联网MQTT—发布消息</a><br><a href="https://mp.weixin.qq.com/s/JfiRb6vRj7mzU6B7Xgep5Q">物联网MQTT—取消订阅</a><br><a href="https://mp.weixin.qq.com/s/mUf14nnOu94aQT27Dfl5VQ">物联网MQTT—订阅主题</a><br><a href="https://mp.weixin.qq.com/s/w027_ZypWjOC5x77PlkVoQ">物联网MQTT—Connect控制报文</a><br><a href="https://mp.weixin.qq.com/s/EDb84h3DxtQ26UPSv0uWaQ">皮一下—B站粉丝显示器</a><br><a href="https://mp.weixin.qq.com/s/J5D3OvDPWHs7E0-zjj7GdA">物联网开其实真的很简单，不信你看！</a><br><a href="https://mp.weixin.qq.com/s/qkC1895BezrKWD07dP1Odg">物联网开发板小熊派BearPi开箱评测</a><br><a href="https://mp.weixin.qq.com/s/vXm0nl1BUeH3yZdHuTNjVg">零基础编写一个串口&amp;网络调试助手</a><br><a href="https://mp.weixin.qq.com/s/mX98FHXOfQHFDyEdVbu6JQ">干货|终于把TCP/UDP协议整明白了！</a><br><a href="https://mp.weixin.qq.com/s/m-UsTShtOjhxBz93b_diHQ">基于SYN7318智能家居语音识别系统的设计</a></p><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p><a href="https://mp.weixin.qq.com/s/j5ra-WO0c1lRVXST1zi2eQ">Github+Hexo博客搭建小白教程（一）</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjU4NzI2NA==&mid=2247493433&idx=1&sn=c001c82c961919076f3383a162fa1bde&source=41#wechat_redirect">Github+Hexo博客搭建小白教程（二）</a><br><a href="https://mp.weixin.qq.com/s/GmhopoSX_ECWFcZFRmXaGw">Github+Hexo博客搭建小白教程（三）</a><br><a href="https://mp.weixin.qq.com/s/_Y9-00xX6WRP1X8mpdUIpQ">Github+Hexo博客搭建小白教程（四）</a><br><a href="https://mp.weixin.qq.com/s/8VnIgCYdP3a_Y-q_5IbNmA">Github+Hexo博客搭建小白教程（五）</a><br><a href="https://mp.weixin.qq.com/s/JkdzkpofsCk5eKOPyc_etA">Github+Hexo博客搭建小白教程（六）</a></p><h2 id="电赛相关"><a href="#电赛相关" class="headerlink" title="电赛相关"></a>电赛相关</h2><p><a href="https://mp.weixin.qq.com/s/luKNclEq2Liddo-tCdujvQ">电赛预热—电源软件如何准备？</a><br><a href="https://mp.weixin.qq.com/s/RbJ9aHik03C1UBwJMtmxEg">微电网模拟系统—2017年电赛A题</a><br><a href="https://mp.weixin.qq.com/s/6pLvV6BgPXCZWtaYYRn8DQ">变流器负载试验中的能量回馈装置</a><br><a href="https://mp.weixin.qq.com/s/7dA98kD8LNWXhKLelbbkEw">大一就开始参加电赛？看学长是咋学的！</a><br><a href="https://mp.weixin.qq.com/s/usfbDQ6dNAFosGaanbT88Q">全国大学生电子设计竞赛(一)–电源简介</a><br><a href="https://mp.weixin.qq.com/s/x2G9Hl8Zv3hlFOfgLux1eA">全国大学生电子设计竞赛(二)–检波与采样</a><br><a href="https://mp.weixin.qq.com/s/xa3o6SjaeFCSDEWV_BS6Nw">全国大学生电子设计竞赛(三)–SPWM与PID</a><br><a href="https://mp.weixin.qq.com/s/zTTUWlth4VHPGdPxvlbDTg">全国大学生电子设计竞赛(四)–Buck与Boost</a><br><a href="https://mp.weixin.qq.com/s/zkarPeYMLEM3WR7cGSikBA">全国大学生电子设计竞赛(五)–整流电路</a><br><a href="https://mp.weixin.qq.com/s/OqxpJpI-EFAnlR-9HBNVlQ">全国大学生电子设计竞赛(六)–逆变电路</a><br><a href="https://mp.weixin.qq.com/s/r65X_h5vCqOCGow3oe47aQ">2020电赛C题—ADS1292R心电图检测仪</a><br><a href="https://mp.weixin.qq.com/s/tt4zHB3XySpuQi91Bo9a7g">2020电赛D题—可穿戴体温测量仪LMT70</a></p><p>在未来的日子里，我仍将坚持更新分享个人学习心得和项目资源，再也衷心感谢各位朋友们的关注与支持！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210715171443971.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：公众号到现在已经陆续更新100多篇原创图文了。今天汇总一下原创图文，一来方便自己</summary>
      
    
    
    
    <category term="公众号" scheme="http://liuyao-blog.cn/categories/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
    
    <category term="公众号" scheme="http://liuyao-blog.cn/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>零基础教你教你写一个安卓app</title>
    <link href="http://liuyao-blog.cn/posts/1002.html"/>
    <id>http://liuyao-blog.cn/posts/1002.html</id>
    <published>2021-08-22T07:48:49.000Z</published>
    <updated>2021-08-24T05:51:51.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210715171443971.png" alt=" "></p><p><strong>摘要</strong>：最近有很多小伙伴在后台留言：Android Studio。我想大家是想写一个手机app，前面已经分享了在QT上如何写一个安卓蓝牙app，虽然qt可以做app，但是比起Android Studio还是差很多。这里介绍一种快速入门的方法来制作一款app，就算你是零基础小白没有学习过java语言也没有关系，相信看完我的文章，半天时间也能做一个安卓app。本文针对初学者，大佬勿喷啊</p><h2 id="1-创建HelloWorld项目"><a href="#1-创建HelloWorld项目" class="headerlink" title="1. 创建HelloWorld项目"></a>1. 创建HelloWorld项目</h2><p>这里我就不介绍如何安装这个Android Studio软件了，网上有很多教程或者去B站找对应的安装视频就可以了。安装好软件之后就开始按照下面的步骤新建工程了。</p><p><img src="https://img-blog.csdnimg.cn/20200811120211633.png" alt=" ">选择一个空应用</p><p><img src="https://img-blog.csdnimg.cn/20200811120256931.png" alt=" ">按照图片的配置方法，设置好工程名和路径</p><p><img src="https://img-blog.csdnimg.cn/20200811120931189.png" alt=" "></p><h2 id="2-修改阿里云镜像源"><a href="#2-修改阿里云镜像源" class="headerlink" title="2. 修改阿里云镜像源"></a>2. 修改阿里云镜像源</h2><p>这一步一定要需要，不然的话你需要编译很久，因为在sync的过程中要下载的很多资源是在外网的，这里使用阿里云镜像源就会很快。修改后只对本项目有效：</p><p><img src="https://img-blog.csdnimg.cn/2020081112113139.png" alt=" ">第一处代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span>&#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;</span>&#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/repositories/google&#x27;</span>&#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>第二处代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span> &#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;</span> &#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/repositories/google&#x27;</span> &#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200811122002400.png" alt=" "></p><p>这样编译起来就会快很多，建议这样修改，不然很可能下载失败导致编译不成功！</p><p><img src="https://img-blog.csdnimg.cn/2020081112214074.png" alt=" "></p><h2 id="3-真机调试"><a href="#3-真机调试" class="headerlink" title="3. 真机调试"></a>3. 真机调试</h2><p>我们可以编译完成后打包成apk文件发送到你的手机进行安装运行，但我建议还是手机连上数据线在线调试比较好，省去很多时间也非常方便。手机连接电脑后打开USB调试，这里以华为荣耀V10手机作为参考。</p><ul><li>1.选择USB连接方式是MIDI(将设备用做MIDI输入设备)</li><li>2.在设置的“系统和更新”—&gt;开发人员选项—&gt;打开USB调试</li></ul><p><img src="https://img-blog.csdnimg.cn/2020081112330279.png" alt=" "></p><p>然后点击这个三角形，就可以看到手机上的APP显示了。</p><p><img src="https://img-blog.csdnimg.cn/20200811124829131.png" alt=" "></p><p>运行结果和上图一样。到这里我们已经完成了一个app的制作怎么样是不是很简单啊！</p><p>接下来介绍一下代码目录，方便大家能够快速的掌握和了解项目所生成文件功能和用途！</p><h2 id="4-Android代码目录"><a href="#4-Android代码目录" class="headerlink" title="4. Android代码目录"></a>4. Android代码目录</h2><p>这里有两种文件架构，所打开的也是两种不同的目录文件。</p><p><img src="https://img-blog.csdnimg.cn/20200811124259926.png" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20200811125548767.png" alt=" "></p><h2 id="5-Android应用程序大致启动流程"><a href="#5-Android应用程序大致启动流程" class="headerlink" title="5. Android应用程序大致启动流程"></a>5. Android应用程序大致启动流程</h2><h3 id="5-1-APP配置文件"><a href="#5-1-APP配置文件" class="headerlink" title="5.1. APP配置文件"></a>5.1. APP配置文件</h3><p><img src="https://img-blog.csdnimg.cn/20200811130034321.png" alt=" "></p><h3 id="5-2-活动文件（Java）"><a href="#5-2-活动文件（Java）" class="headerlink" title="5.2. 活动文件（Java）"></a>5.2. 活动文件（Java）</h3><p><img src="https://img-blog.csdnimg.cn/20200811131422515.png" alt=" "></p><h3 id="5-3-布局文件（XML）"><a href="#5-3-布局文件（XML）" class="headerlink" title="5.3. 布局文件（XML）"></a>5.3. 布局文件（XML）</h3><p>Android设计讲究前后端分离设计，上面的java文件是后端，引入了activity_main这个前端界面布局文件，如果想再设计一个界面就在layout文件夹下再新建一个 ==.xml==文件就可以了。</p><p><img src="https://img-blog.csdnimg.cn/20200811131730466.png" alt=" "></p><h3 id="5-4-res资源目录（统一管理）"><a href="#5-4-res资源目录（统一管理）" class="headerlink" title="5.4. res资源目录（统一管理）"></a>5.4. res资源目录（统一管理）</h3><p><img src="https://img-blog.csdnimg.cn/20200811132432292.png" alt=" "></p><h4 id="5-4-1-colors-xml"><a href="#5-4-1-colors-xml" class="headerlink" title="5.4.1. colors.xml"></a>5.4.1. colors.xml</h4><p><img src="https://img-blog.csdnimg.cn/2020081113274675.png" alt=" "></p><p>三个颜色有点少我们可以在加一些颜色但这里面来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;color name=<span class="string">&quot;white&quot;</span>&gt;#FFFFFF&lt;/color&gt; &lt;!--白色 --&gt;</span><br><span class="line">&lt;color name=<span class="string">&quot;ivory&quot;</span>&gt;#FFFFF0&lt;/color&gt; &lt;!--象牙色 --&gt;</span><br><span class="line">&lt;color name=<span class="string">&quot;lightyellow&quot;</span>&gt;#FFFFE0&lt;/color&gt; &lt;!--亮黄色 --&gt;</span><br><span class="line">&lt;color name=<span class="string">&quot;yellow&quot;</span>&gt;#FFFF00&lt;/color&gt; &lt;!--黄色 --&gt;</span><br><span class="line">&lt;color name=<span class="string">&quot;snow&quot;</span>&gt;#FFFAFA&lt;/color&gt; &lt;!--雪白色 --&gt;</span><br><span class="line">&lt;color name=<span class="string">&quot;floralwhite&quot;</span>&gt;#FFFAF0&lt;/color&gt; &lt;!--花白色 --&gt;</span><br><span class="line">&lt;color name=<span class="string">&quot;lemonchiffon&quot;</span>&gt;#FFFACD&lt;/color&gt; &lt;!--柠檬绸色 --&gt;</span><br><span class="line">&lt;color name=<span class="string">&quot;cornsilk&quot;</span>&gt;#FFF8DC&lt;/color&gt; &lt;!--米绸色 --&gt;</span><br></pre></td></tr></table></figure><h4 id="5-4-2-strings-xml"><a href="#5-4-2-strings-xml" class="headerlink" title="5.4.2. strings.xml"></a>5.4.2. strings.xml</h4><p><img src="https://img-blog.csdnimg.cn/20200811133344664.png" alt=" "></p><h4 id="5-4-3-styles-xml"><a href="#5-4-3-styles-xml" class="headerlink" title="5.4.3. styles.xml"></a>5.4.3. styles.xml</h4><p><img src="https://img-blog.csdnimg.cn/20200811133529498.png" alt=" ">***</p><h2 id="5、主界面布置"><a href="#5、主界面布置" class="headerlink" title="5、主界面布置"></a>5、主界面布置</h2><h3 id="5-1线性布局-LinearLayout"><a href="#5-1线性布局-LinearLayout" class="headerlink" title="5.1线性布局(LinearLayout)"></a>5.1线性布局(LinearLayout)</h3><p>线性布局的形式可以分为两种，第一种横向线性布局，第二种纵向线性布局，总而言之都是以线性的形式一个个排列出来的，纯线性布局的缺点是很不方便修改控件的显示位置，所以开发中经常会以线性布局与相对布局嵌套的形式设置布局。</p><h3 id="5-2相对布局-RelativeLayout"><a href="#5-2相对布局-RelativeLayout" class="headerlink" title="5.2相对布局(RelativeLayout)"></a>5.2相对布局(RelativeLayout)</h3><p>相对布局是android布局中最为强大的，首先它可以设置的属性是最多了，其次它可以做的事情也是最多的。android手机屏幕的分辨率五花八门，为了考虑屏幕自适应的情况，在开发中建议大家都去使用相对布局，它的坐标取值范围都是相对的，所以使用它来做自适应屏幕是正确的。</p><h3 id="5-3帧布局-FrameLayout"><a href="#5-3帧布局-FrameLayout" class="headerlink" title="5.3帧布局(FrameLayout)"></a>5.3帧布局(FrameLayout)</h3><p>帧布局原理是在控件中绘制任何一个控件都可以被后绘制的控件覆盖，最后绘制的控件会盖住之前的控件。界面中先绘制的ImageView 然后再绘制的TextView和EditView，后者就会覆盖在前者上面。</p><h3 id="5-4绝对布局-AbsoluteLayout"><a href="#5-4绝对布局-AbsoluteLayout" class="headerlink" title="5.4绝对布局(AbsoluteLayout)"></a>5.4绝对布局(AbsoluteLayout)</h3><p>使用绝对布局可以设置任意控件在屏幕中XY坐标点，和帧布局一样绘制的控件会覆盖住之前绘制的控件，不建议大家使用绝对布局。android的手机分辨率五花八门，使用绝对布局的话在其它分辨率的手机上就无法正常的显示了。</p><h3 id="5-5表格布局-TableLayout"><a href="#5-5表格布局-TableLayout" class="headerlink" title="5.5表格布局(TableLayout)"></a>5.5表格布局(TableLayout)</h3><p>在表格布局中可以设置TableRow，可以设置表格中每一行显示的内容以及位置 ，可以设置显示的缩进，对齐的方式。</p><p>在实际应用中线行布局和相对布局是最常用的，一般自己写的app布局都相对比较简单，所以这里我们使用线性布局。打开APP配置文件中的<code>activity_main.xml</code>，就可以在这里面愉快的编程了。如果你之前没有玩过Android Studio也没有关系，左边修改右边预览多试试几次就大概明白了。</p><p><img src="https://img-blog.csdnimg.cn/20210427213553668.png" alt=" "></p><p>在这里我们可以修改点击图片所转换的网址，大家打开源码就知道如何修改了，这里就不在赘述！</p><p><img src="https://img-blog.csdnimg.cn/20210427213448601.png" alt=" "></p><p>在<code>activity_main.xml</code>文件中我们可以修改界面的布局。</p><p><img src="https://img-blog.csdnimg.cn/20210427213553668.png" alt=" "></p><p>到这里基本上一个简单的安卓应用就完成了。只要你安装了Android Studio软件并且拿到我的源码就可以愉快的玩耍了。什么？你拿到我的代码却不能正常编译通过？下面就教大家如何把别人的源码拿到自己的软件中编译通过！</p><h2 id="6、代码移植"><a href="#6、代码移植" class="headerlink" title="6、代码移植"></a>6、代码移植</h2><p>以下是需要修改文件的地方，具体修改成啥样，可以参考一个你可以打的开的工程中的配置，参考对应的文件即可。</p><p><img src="https://img-blog.csdnimg.cn/20200821171112615.png#pic_center" alt=" "></p><h3 id="1-修改build-gradle文件"><a href="#1-修改build-gradle文件" class="headerlink" title="1.修改build.gradle文件"></a>1.修改build.gradle文件</h3><p><img src="https://img-blog.csdnimg.cn/20200821171335837.png" alt=" "></p><h3 id="2-修改app-build-gradle文件"><a href="#2-修改app-build-gradle文件" class="headerlink" title="2.修改app/build.gradle文件"></a>2.修改app/build.gradle文件</h3><p>修改版本号</p><p><img src="https://img-blog.csdnimg.cn/20200821171514675.png#pic_center" alt=" "></p><h3 id="3-修改gradle-wrapper-gradle-wrapper-properties"><a href="#3-修改gradle-wrapper-gradle-wrapper-properties" class="headerlink" title="3.修改gradle/wrapper/gradle-wrapper.properties"></a>3.修改gradle/wrapper/gradle-wrapper.properties</h3><p>这个地方修改成你可以打开的工程的 ==. zip==包</p><p><img src="https://img-blog.csdnimg.cn/20200821171554198.png#pic_center" alt=" "></p><h3 id="4-修改local-properties"><a href="#4-修改local-properties" class="headerlink" title="4.修改local.properties"></a>4.修改local.properties</h3><p>这个地方是你的软件安装路径所在的位置，要修改成你自己的安装路径</p><p><img src="https://img-blog.csdnimg.cn/20200821171629501.png#pic_center" alt=" "></p><p>公众号后台回复：firstapp，即可获取源码和教程文档！</p><p><img src="https://img-blog.csdnimg.cn/20210715171459939.png" alt=" "></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210715171443971.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：最近有很多小伙伴在后台留言：Android Studio。我想大家是想写一个手机</summary>
      
    
    
    
    <category term="安卓app" scheme="http://liuyao-blog.cn/categories/%E5%AE%89%E5%8D%93app/"/>
    
    
    <category term="APP" scheme="http://liuyao-blog.cn/tags/APP/"/>
    
    <category term="安卓" scheme="http://liuyao-blog.cn/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
</feed>
